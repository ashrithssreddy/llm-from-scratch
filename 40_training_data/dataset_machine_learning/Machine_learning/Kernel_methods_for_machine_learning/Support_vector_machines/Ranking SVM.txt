In machine learning, a ranking SVM is a variant of the support vector machine algorithm, which is used to solve certain ranking problems (via learning to rank). The ranking SVM algorithm was published by Thorsten Joachims in 2002.

The original purpose of the algorithm was to improve the performance of an internet search engine. However, it was found that ranking SVM also can be used to solve other problems such as Rank SIFT.

Description

The ranking SVM algorithm is a learning retrieval function that employs pairwise ranking methods to adaptively sort results based on how 'relevant' they are for a specific query. The ranking SVM function uses a mapping function to describe the match between a search query and the features of each of the possible results. This mapping function projects each data pair (such as a search query and clicked web-page, for example) onto a feature space. These features are combined with the corresponding click-through data (which can act as a proxy for how relevant a page is for a specific query) and can then be used as the training data for the ranking SVM algorithm.

Generally, ranking SVM includes three steps in the training period:

It maps the similarities between queries and the clicked pages onto a certain feature space.

It calculates the distances between any two of the vectors obtained in step 1.

It forms an optimization problem which is similar to a standard SVM classification and solves this problem with the regular SVM solver.

Background

Ranking method

Suppose \mathbb{C} is a data set containing N elements c_i.  r  is a ranking method applied to \mathbb{C}. Then

the  r in \mathbb{C} can be represented as a N \times N binary matrix. If the rank of c_i is higher than the rank of c_j, i.e. r\ c_i , the corresponding position of this matrix is set to value of "1". Otherwise the element in that position will be set as the value "0".

Kendall's tau

Source:

Kendall's Tau also refers to Kendall tau rank correlation coefficient, which is commonly used to compare two ranking methods for the same data set.

Suppose r_1 and  r_2 are two ranking method applied to data set \mathbb{C}, the Kendall's Tau between r_1 and r_2 can be represented as follows:

\tau (r_1,r_2) = {P-Q \over P+Q} = 1- {2Q \over P+Q}

where P is the number of concordant pairs  and Q is the number of discordant pairs (inversions). A pair d_i and d_j is concordant if both r_a and r_b agree in how they order d_i and d_j . It is discordant if they disagree.

Information retrieval quality

Source:

Information retrieval quality is usually evaluated by the following three measurements:

Precision

Recall

Average precision

For a specific query to a database, let P_{relevant} be the set of relevant information elements in the database and P_{retrieved} be the set of the retrieved information elements. Then the above three measurements can be represented as follows:

\begin{align}

& \text{precision} = \frac{ \left| P_\text{relevant} \cap P_\text{retrieved} \right|}{\left| P_\text{retrieved} \right|}; \\[6pt]

& \text{recall} = \frac{\left| P_\text{relevant} \cap P_\text{retrieved} \right|}{\left| P_\text{relevant} \right|} ;\\[6pt]

& \text{average precision} = \int_0^1 \text{Prec}(\text{recall}) \, d\text{recall},\\

\end{align}

where \text{Prec}(\text{Recall}) is the \text{Precision} of \text{Recall}.

Let r^* and r_{f(q)} be the expected and proposed ranking methods of a database respectively, the lower bound of Average Precision of method r_{f(q)} can be represented as follows:

\operatorname{AvgPrec}(r_{f(q)}) \geqq {1 \over R} \left[ Q+ \binom{R+1}{2} \right ]^{-1} \left( \sum_{i=1}^R \sqrt i \right)^2

where Q is the number of different elements in the upper triangular parts of matrices of r^* and r_{f(q)} and R is the number of relevant elements in the data set.

SVM classifier

Source:

Suppose (\vec x_i,y_i) is the element of a training data set, where \vec x_i is the feature vector and y_i is the label (which classifies the category of \vec x_i). A typical SVM classifier for such data set can be defined as the solution of the following optimization problem.

\begin{align}

& \text{minimize } V(\vec w, \vec \xi) = {1 \over 2} \vec w \cdot \vec w + CF \sum \xi_i^\sigma \\[6pt]

& \text{subject to} \\[6pt]

& \begin{array}{l}

\sigma \geqq 0;\\

\forall y_i(\vec w \vec x_i +b) \geqq 1-\xi_i^\sigma;

\end{array}

\\[6pt]

& \mathrm{where } \\[6pt]

& \begin{array}{l}

b \text{ is a scalar;}\\

\forall y_i \in \left \{ -1,1 \right \};\\

\forall \xi_i \geqq 0;\\

\end{array}

\end{align}

The solution of the above optimization problem can be represented as a linear combination of the feature vectors x_is.

\vec w^* = \sum_i \alpha_i y_i x_i

where \alpha_i is the coefficients to be determined.

Ranking SVM algorithm

Loss function

Let  \tau_{P(f)} be the Kendall's tau between expected ranking method r^* and proposed method r_{f(q)}, it can be proved that maximizing  \tau_{P(f)} helps to minimize the lower bound of the Average Precision of r_{f(q)}.

Expected loss function

The negative  \tau_{P(f)} can be selected as the loss function to minimize the lower bound of average precision of r_{f(q)}

L_\text{expected}=-\tau_{P(f)}=-\int \tau(r_{f(q)},r^*) \, dPr(q,r^*)

where Pr(q,r^*) is the statistical distribution of r^* to certain query q.

Empirical loss function

Since the expected loss function is not applicable, the following empirical loss function is selected for the training data in practice.

L_\text{empirical} = - \tau_S(f)= -{1 \over n} \sum_{i=1}^n \tau(r_{f(q_i)},r_i^*)

Collecting training data

n i.i.d. queries are applied to a database and each query corresponds to a ranking method. The training data set has n elements. Each element contains a query and the corresponding ranking method.

Feature space

A mapping function \Phi(q,d) is required to map each query and the element of database to a feature space. Then each point in the feature space is labelled with certain rank by ranking method.

Optimization problem

The points generated by the training data are in the feature space, which also carry the rank information (the labels). These labeled points can be used to find the boundary (classifier) that specifies the order of them. In the linear case, such boundary (classifier) is a vector.

Suppose c_i and c_j are two elements in the database and denote (c_i,c_j) \in r  if the rank of c_i is higher than c_j in certain ranking method r. Let vector \vec w be the linear classifier candidate in the feature space. Then the ranking problem can be translated to the following SVM classification problem. Note that one ranking method corresponds to one query.

\begin{align}

& \text{minimize } V(\vec w, \vec \xi) = {1 \over 2} \vec w \cdot \vec w + \text{constant} \cdot \sum \xi_{i,j,k} \\[6pt]

& \text{subject to} \\[6pt]

& \begin{array}{l}

\forall \xi_{i,j,k} \geqq 0\\

\forall (c_i, c_j)\in r_k^*\\

\vec w (\Phi(q_1,c_i)-\Phi(q_1, c_j)) \geqq 1- \xi_{i,j,1};\\

\,\,\,\vdots \\

\vec w (\Phi(q_n, c_i)-\Phi(q_n, c_j)) \geqq 1-\xi_{i,j,n};\\

\text{where } k \in \left \{ 1,2,\ldots, n \right \},\ i,j \in \left \{ 1,2,\ldots \right \}.

\end{array}

\end{align}

The above optimization problem is identical to the classical SVM classification problem, which is the reason why this algorithm is called Ranking-SVM.

Retrieval function

The optimal vector \vec w^* obtained by the training sample is

\vec w^*=\sum \alpha_{k,\ell}^*\Phi(q_k,c_i)

So the retrieval function could be formed based on such optimal classifier.

For new query q, the retrieval function first projects all elements of the database to the feature space. Then it orders these feature points by the values of their inner products with the optimal vector. And the rank of each feature point is the rank of the corresponding element of database for the query q.

Application of ranking SVM

Ranking SVM can be applied to rank the pages according to the query. The algorithm can be trained using click-through data, where consists of the following three parts:

Query.

Present ranking of search results

Search results clicked on by user

The combination of 2 and 3 cannot provide full training data order which is needed to apply the full SVM algorithm. Instead, it provides a part of the ranking information of the training data. So the algorithm can be slightly revised as follows.

\begin{align}

& \text{minimize } V(\vec w, \vec \xi) = {1 \over 2} \vec w \cdot \vec w + \text{constant} \cdot \sum \xi_{i,j,k} \\[6pt]

& \text{subject to} \\[6pt]

& \begin{array}{l}

\forall \xi_{i,j,k} \geqq 0\\

\forall (c_i, c_j)\in r_k'\\

\vec w (\Phi(q_1,c_i)-\Phi(q_1,c_j)) \geqq 1- \xi_{i,j,1};\\

\,\,\, \vdots \\

\vec w (\Phi(q_n,c_i)-\Phi(q_n,c_j)) \geqq 1- \xi_{i,j,n};\\

\text{where }\ k \in \left \{ 1,2,\ldots,n \right \},\ i,j \in \left \{ 1,2,\ldots \right \}.

\end{array}

\end{align}

The method r' does not provide ranking information of the whole dataset, it's a subset of the full ranking method. So the condition of optimization problem becomes more relax compared with the original Ranking-SVM.

References

Category:Support vector machines