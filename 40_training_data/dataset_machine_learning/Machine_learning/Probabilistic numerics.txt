Probabilistic numerics is an active field of study at the intersection of applied mathematics, statistics, and machine learning centering on the concept of uncertainty in computation. In probabilistic numerics, tasks in numerical analysis such as finding numerical solutions for integration, linear algebra, optimization and simulation and differential equations are seen as problems of statistical, probabilistic, or Bayesian inference.

Introduction

A numerical method is an algorithm that approximates the solution to a mathematical problem (examples below include the solution to a linear system of equations, the value of an integral, the solution of a differential equation, the minimum of a multivariate function). In a probabilistic numerical algorithm, this process of approximation is thought of as a problem of estimation, inference or learning and realised in the framework of probabilistic inference (often, but not always, Bayesian inference).

Formally, this means casting the setup of the computational problem in terms of a prior distribution, formulating the relationship between numbers computed by the computer (e.g. matrix-vector multiplications in linear algebra, gradients in optimization, values of the integrand or the vector field defining a differential equation) and the quantity in question (the solution of the linear problem, the minimum, the integral, the solution curve) in a likelihood function, and returning a posterior distribution as the output. In most cases, numerical algorithms also take internal adaptive decisions about which numbers to compute, which form an active learning problem.

Many of the most popular classic numerical algorithms can be re-interpreted in the probabilistic framework. This includes the method of conjugate gradients, and quasi-Newton methods. In all these cases, the classic method is based on a regularized least-squares estimate that can be associated with the posterior mean arising from a Gaussian prior and likelihood. In such cases, the variance of the Gaussian posterior is then associated with a worst-case estimate for the squared error.

Probabilistic numerical methods promise several conceptual advantages over classic, point-estimate based approximation techniques:

They return structured error estimates (in particular, the ability to return joint posterior samples, i.e. multiple realistic hypotheses for the true unknown solution of the problem)

Hierarchical Bayesian inference can be used to set and control internal hyperparameters in such methods in a generic fashion, rather than having to re-invent novel methods for each parameter

Since they use and allow for an explicit likelihood describing the relationship between computed numbers and target quantity, probabilistic numerical methods can use the results of even highly imprecise, biased and stochastic computations. Conversely, probabilistic numerical methods can also provide a likelihood in computations often considered "likelihood-free" elsewhere

Because all probabilistic numerical methods use essentially the same data type – probability measures – to quantify uncertainty over both inputs and outputs they can be chained together to propagate uncertainty across large-scale, composite computations

Sources from multiple sources of information (e.g. algebraic, mechanistic knowledge about the form of a differential equation, and observations of the trajectory of the system collected in the physical world) can be combined naturally and inside the inner loop of the algorithm, removing otherwise necessary nested loops in computation, e.g. in inverse problems.

These advantages are essentially the equivalent of similar functional advantages that Bayesian methods enjoy over point-estimates in machine learning, applied or transferred to the computational domain.

Numerical tasks

Integration

Probabilistic numerical methods have been developed for the problem of numerical integration, with the most popular method called Bayesian quadrature.

In numerical integration, function evaluations f(x_1), \ldots, f(x_n) at a number of points x_1, \ldots, x_n are used to estimate the integral  \textstyle \int f(x) \nu(dx)  of a function  f  against some measure  \nu . Bayesian quadrature consists of specifying a prior distribution over f and conditioning this prior on f(x_1), \ldots, f(x_n) to obtain a posterior distribution over f, then computing the implied posterior distribution on  \textstyle \int f(x) \nu(dx) . The most common choice of prior is a Gaussian process as this allows us to obtain a closed-form posterior distribution on the integral which is a univariate Gaussian distribution. Bayesian quadrature is particularly useful when the function  f  is expensive to evaluate and the dimension of the data is small to moderate.

Optimization

Probabilistic numerics have also been studied for mathematical optimization, which consist of finding the minimum or maximum of some objective function  f  given (possibly noisy or indirect) evaluations of that function at a set of points.

Perhaps the most notable effort in this direction is Bayesian optimization, a general approach to optimization grounded in Bayesian inference. Bayesian optimization algorithms operate by maintaining a probabilistic belief about  f  throughout the optimization procedure; this often takes the form of a Gaussian process prior conditioned on observations. This belief then guides the algorithm in obtaining observations that are likely to advance the optimization process. Bayesian optimization policies are usually realized by transforming the objective function posterior into an inexpensive, differentiable acquisition function that is maximized to select each successive observation location. One prominent approach is to model optimization via Bayesian sequential experimental design, seeking to obtain a sequence of observations yielding the most optimization progress as evaluated by an appropriate utility function. A welcome side effect from this approach is that uncertainty in the objective function, as measured by the underlying probabilistic belief, can guide an optimization policy in addressing the classic exploration vs. exploitation tradeoff.

Local optimization

Probabilistic numerical methods have been developed in the context of stochastic optimization for deep learning, in particular to address main issues such as

learning rate tuning and line searches,

batch-size selection, early stopping,

pruning, and first- and second-order search directions.

In this setting, the optimization objective is often an empirical risk of the form \textstyle L(\theta) = \frac{1}{N}\sum_{n=1}^N \ell(y_n, f_{\theta}(x_n))  defined by a dataset \textstyle \mathcal{D}=\{(x_n, y_n)\}_{n=1}^N, and a loss \ell(y, f_{\theta}(x))  that quantifies how well a predictive model  f_{\theta}(x) parameterized by  \theta  performs on predicting the target  y  from its corresponding input  x  .

Epistemic uncertainty arises when the dataset size  N  is large and cannot be processed at once meaning that local quantities (given some  \theta ) such as the loss function   L(\theta)  itself or its gradient \nabla L(\theta) cannot be computed in reasonable time.

Hence, generally mini-batching is used to construct estimators of these quantities on a random subset of the data. Probabilistic numerical methods model this uncertainty explicitly and allow for automated decisions and parameter tuning.

Linear algebra

Probabilistic numerical methods for linear algebra

have primarily focused on solving systems of linear equations of the form Ax=b and the computation of determinants |A|.

regression. This was later improved (in terms of efficient computation) in favor of GaussMarkov priors modeled by the stochastic differential equation  \mathrm{d}x(t) = A x(t) \, \mathrm{d} t + B \, \mathrm{d}v(t) , where   x(t)  is a  \nu -dimensional vector modeling the first  \nu  derivatives of  y(t) , and where  v(t)  is a  \nu -dimensional Brownian motion. Inference can thus be implemented efficiently with Kalman filtering based methods.

The boundary between these two categories is not sharp, indeed a Gaussian process regression approach based on randomised data was developed as well. These methods have been applied to problems in computational Riemannian geometry, inverse problems, latent force models, and to differential equations with a geometric structure such as symplecticity.

Partial differential equations

A number of probabilistic numerical methods have also been proposed for partial differential equations. As with ordinary differential equations, the approaches can broadly be divided into those based on randomisation, generally of some underlying finite-element mesh and those based on Gaussian process regression.

on a function f \colon \mathbb{R} \to \mathbb{R}, expressed as a formal power series with random coefficients, and asked for "probable values" of f(x) given this prior and n \in \mathbb{N} observations f(a_{i}) = B_{i} for i = 1, \dots, n.

A later seminal contribution to the interplay of numerical analysis and probability was provided by Albert Suldin in the context of univariate quadrature.  The statistical problem considered by Suldin was the approximation of the definite integral \textstyle \int u(t) \, \mathrm{d} t of a function u \colon [a, b] \to \mathbb{R}, under a Brownian motion prior on u, given access to pointwise evaluation of u at nodes t_{1}, \dots, t_{n} \in [a, b].  Suldin showed that, for given quadrature nodes, the quadrature rule with minimal mean squared error is the trapezoidal rule;  furthermore, this minimal error is proportional to the sum of cubes of the inter-node spacings.  As a result, one can see the trapezoidal rule with equally-spaced nodes as statistically optimal in some sense — an early example of the average-case analysis of a numerical method.

Suldin's point of view was later extended by Mike Larkin.

Note that Suldin's Brownian motion prior on the integrand u is a Gaussian measure and that the operations of integration and of point wise evaluation of u are both linear maps.

Thus, the definite integral \textstyle \int u(t) \, \mathrm{d} t is a real-valued Gaussian random variable.

In particular, after conditioning on the observed pointwise values of u, it follows a normal distribution with mean equal to the trapezoidal rule and variance equal to \textstyle \frac{1}{12} \sum_{i = 2}^{n} (t_{i} - t_{i - 1})^{3}.

This viewpoint is very close to that of Bayesian quadrature, seeing the output of a quadrature method not just as a point estimate but as a probability distribution in its own right.

As noted by Houman Owhadi and collaborators, interplays between numerical approximation  and statistical inference can also be traced back to Palasti and Renyi, Sard,  Kimeldorf and Wahba (on the correspondence between Bayesian estimation and spline smoothing/interpolation) and Larkin the branch of computational complexity founded on the observation that numerical implementation requires computation with partial information and limited resources. In IBC, the performance of an algorithm operating on incomplete information can be analyzed in the  worst-case or the average-case (randomized) setting  with respect to the missing information. Moreover, as Packel observed, the average case setting could be interpreted as a mixed strategy in an adversarial game obtained by lifting a (worst-case) minmax problem to a minmax problem over mixed (randomized) strategies. This observation leads to a natural connection in which one tries to approximate an unknown function from a finite number of linear measurements on that function. Interpreting this optimal recovery problem as a zero-sum game where Player I selects the unknown function and Player II selects its approximation, and using relative errors in a quadratic norm to define losses, Gaussian priors emerge  as optimal mixed strategies for such games, and the covariance operator of the optimal Gaussian prior is determined by the quadratic norm used to define the relative error of the recovery.

Software

ProbNum: Probabilistic Numerics in Python.

ProbNumDiffEq.jl: Probabilistic numerical ODE solvers based on filtering implemented in Julia.

Emukit: Adaptable Python toolbox for decision-making under uncertainty.

BackPACK: Built on top of PyTorch. It efficiently computes quantities other than the gradient.

See also

Average-case analysis

Information-based complexity

Uncertainty quantification

References

Category:Applied statistics

Category:Machine learning

Category:Applied mathematics