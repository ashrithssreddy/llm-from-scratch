Anti-unification is the process of constructing a generalization common to two given symbolic expressions. As in unification, several frameworks are distinguished depending on which expressions (also called terms) are allowed, and which expressions are considered equal. If variables representing functions are allowed in an expression, the process is called "higher-order anti-unification", otherwise "first-order anti-unification". If the generalization is required to have an instance literally equal to each input expression, the process is called "syntactical anti-unification", otherwise "E-anti-unification", or "anti-unification modulo theory".

An anti-unification algorithm should compute for given expressions a complete and minimal generalization set, that is, a set covering all generalizations and containing no redundant members, respectively. Depending on the framework, a complete and minimal generalization set may have one, finitely many, or possibly infinitely many members, or may not exist at all; it cannot be empty, since a trivial generalization exists in any case. For first-order syntactical anti-unification, Gordon Plotkin gave an algorithm that computes a complete and minimal singleton generalization set containing the so-called "least general generalization" (lgg).

Anti-unification should not be confused with dis-unification. The latter means the process of solving systems of inequations, that is of finding values for the variables such that all given inequations are satisfied. This task is quite different from finding generalizations.

Prerequisites

Formally, an anti-unification approach presupposes

An infinite set V of variables. For higher-order anti-unification, it is convenient to choose V disjoint from the set of lambda-term bound variables.

A set T of terms such that V ⊆ T. For first-order and higher-order anti-unification, T is usually the set of first-order terms (terms built from variable and function symbols) and lambda terms (terms containing some higher-order variables), respectively.

An equivalence relation \equiv on T, indicating which terms are considered equal. For higher-order anti-unification, usually t \equiv u if t and u are alpha equivalent. For first-order E-anti-unification, \equiv reflects the background knowledge about certain function symbols; for example, if \oplus is considered commutative, t \equiv u if u results from t by swapping the arguments of \oplus at some (possibly all) occurrences. If there is no background knowledge at all, then only literally, or syntactically, identical terms are considered equal.

First-order term

Given a set V of variable symbols, a set C of constant symbols and sets F_n of n-ary function symbols, also called operator symbols, for each natural number n \geq 1, the set of (unsorted first-order) terms T is recursively defined to be the smallest set with the following properties:

every variable symbol is a term: V ⊆ T,

every constant symbol is a term: C ⊆ T,

from every n terms t1,...,tn, and every n-ary function symbol f ∈ Fn, a larger term f(t_1,\ldots,t_n) can be built.

For example, if x&nbsp;∈ V is a variable symbol, 1&nbsp;∈ C is a constant symbol, and add&nbsp;∈ F2 is a binary function symbol, then x&nbsp;∈ T, 1&nbsp;∈ T, and (hence) add(x,1)&nbsp;∈ T by the first, second, and third term building rule, respectively. The latter term is usually written as x+1, using Infix notation and the more common operator symbol + for convenience.

Higher-order term

Substitution

A substitution is a mapping  \sigma: V \longrightarrow T from variables to terms; the notation \{x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \} refers to a substitution mapping each variable x_i to the term t_i, for i=1,\ldots,k, and every other variable to itself. Applying that substitution to a term  is written in postfix notation as t \{x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \}; it means to (simultaneously) replace every occurrence of each variable x_i in the term  by t_i. The result  of applying a substitution  to a term  is called an instance of that term .

As a first-order example, applying the substitution \{x \mapsto h(a,y), z \mapsto b\} to the term

Generalization, specialization

If a term t has an instance equivalent to a term u, that is, if t \sigma \equiv u for some substitution \sigma, then t is called more general than u, and u is called more special than, or subsumed by, t. For example, x \oplus a is more general than a \oplus b if \oplus is commutative, since then (x \oplus a)\{x \mapsto b\} = b \oplus a \equiv a \oplus b.

If \equiv is literal (syntactic) identity of terms, a term may be both more general and more special than another one only if both terms differ just in their variable names, not in their syntactic structure; such terms are called variants, or renamings of each other.

For example, f(x_1,a,g(z_1),y_1) is a variant of f(x_2,a,g(z_2),y_2), since f(x_1,a,g(z_1),y_1) \{ x_1 \mapsto x_2, y_1 \mapsto y_2, z_1 \mapsto z_2\} = f(x_2,a,g(z_2),y_2) and f(x_2,a,g(z_2),y_2) \{x_2 \mapsto x_1, y_2 \mapsto y_1, z_2 \mapsto z_1\} = f(x_1,a,g(z_1),y_1).

However, f(x_1,a,g(z_1),y_1) is not a variant of f(x_2,a,g(x_2),x_2), since no substitution can transform the latter term into the former one, although \{x_1 \mapsto x_2, z_1 \mapsto x_2, y_1 \mapsto x_2 \} achieves the reverse direction.

The latter term is hence properly more special than the former one.

A substitution \sigma is more special than, or subsumed by, a substitution \tau if x \sigma is more special than x \tau for each variable x.

For example, \{ x \mapsto f(u), y \mapsto f(f(u)) \} is more special than \{ x \mapsto z, y \mapsto f(z) \}, since f(u) and f(f(u))  is more special than z and f(z), respectively.

Anti-unification problem, generalization set

An anti-unification problem is a pair \langle t_1, t_2 \rangle of terms.

A term t is a common generalization, or anti-unifier, of t_1 and t_2 if t \sigma_1 \equiv t_1 and t \sigma_2 \equiv t_2 for some substitutions \sigma_1, \sigma_2.

For a given anti-unification problem, a set S of anti-unifiers is called complete if each generalization subsumes some term t \in S; the set S is called minimal if none of its members subsumes another one.

First-order syntactical anti-unification

The framework of first-order syntactical anti-unification is based on T being the set of first-order terms (over some given set V of variables, C of constants and F_n of n-ary function symbols) and on \equiv being syntactic equality.

In this framework, each anti-unification problem \langle t_1, t_2 \rangle has a complete, and obviously minimal, singleton solution set \{t\}.

Its member t is called the least general generalization (lgg) of the problem, it has an instance syntactically equal to t_1 and another one syntactically equal to t_2.

Any common generalization of  t_1 and t_2 subsumes t.

The lgg is unique up to variants: if S_1 and S_2 are both complete and minimal solution sets of the same syntactical anti-unification problem, then S_1 = \{ s_1\} and S_2 = \{ s_2 \} for some terms s_1 and s_2, that are renamings of each other.

Plotkin

The algorithm consists of two rules:

For example, (0*0) \sqcup (4*4) \rightsquigarrow (0 \sqcup 4)*(0 \sqcup 4) \rightsquigarrow \phi(0,4) * \phi(0,4) \rightsquigarrow x*x; this least general generalization reflects the common property of both inputs of being square numbers.

Plotkin used his algorithm to compute the "relative least general generalization (rlgg)" of two clause sets in first-order logic, which was the basis of the Golem approach to inductive logic programming.

First-order anti-unification modulo theory

Software.

Equational theories

One associative and commutative operation: ;

Commutative theories:

Free monoids:

Regular congruence classes: ;

A-, C-, AC-, ACU-theories with ordered sorts:

Purely idempotent theories:

First-order sorted anti-unification

Taxonomic sorts: ; ;

Feature terms:

A-, C-, AC-, ACU-theories with ordered sorts: see above

Nominal anti-unification

Baumgartner, Alexander; Kutsia, Temur; Levy, Jordi; Villaret, Mateu (Jun 2013). Nominal Anti-Unification. Proc. RTA 2015. Vol. 36 of LIPIcs. Schloss Dagstuhl, 57-73. Software.

Applications

Program analysis:

Code factoring:

Induction proving:

Information Extraction:

Case-based reasoning:

{{cite conference | contribution-url=https://www.researchgate.net/publication/221045334 | last1=Armengol|first2=Enric|last2=Plaza | contribution=Using Symbolic Descriptions to Explain Similarity on {CBR} | editor=Beatriz López and Joaquim Meléndez and Petia Radeva and Jordi Vitrià | title=Artificial Intelligence Research and Development, Proc. 8th Int. Conf. of the ACIA, CCIA | publisher=IOS Press | series= | volume= | pages=239&ndash;246 | year=2005 }}

Program synthesis: The idea of generalizing terms with respect to an equational theory can be traced back to Manna and Waldinger (1978, 1980) who desired to apply it in program synthesis. In section "Generalization", they suggest (on p.&nbsp;119 of the 1980 article) to generalize reverse(l) and reverse(tail(l))<>[head(l)] to obtain reverse(l')<>m' . This generalization is only possible if the background equation u<>[]=u is considered.

&mdash; preprint of the 1980 article

Natural language processing:

Higher-order anti-unification

Calculus of constructions:

Simply typed lambda calculus (Input: Terms in the eta-long beta-normal form. Output:  higher-order patterns):

Baumgartner, Alexander; Kutsia, Temur; Levy, Jordi; Villaret, Mateu (Jun 2013). A Variant of Higher-Order Anti-Unification. Proc. RTA 2013. Vol. 21 of LIPIcs. Schloss Dagstuhl, 113-127. Software.

Simply typed lambda calculus (Input: Terms in the eta-long beta-normal form. Output: Various fragments of the simply typed lambda calculus including patterns):

Restricted Higher-Order Substitutions:

;

Notes

References

Category:Inductive logic programming

Category:Automated theorem proving

Category:Logic in computer science

Category:Unification (computer science)