. Each blue dot represents one Democratic member of the House, and each red dot one Republican.]]

Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a data set.  MDS is used to translate distances between each pair of  n  objects in a set into a configuration of  n  points mapped into an abstract Cartesian space.

More technically, MDS refers to a set of related ordination techniques used in information visualization, in particular to display the information contained in a distance matrix. It is a form of non-linear dimensionality reduction.

Given a distance matrix with the distances between each pair of objects in a set, and a chosen number of dimensions, N, an MDS algorithm places each object into N-dimensional space (a lower-dimensional representation) such that the between-object distances are preserved as well as possible. For N = 1, 2, and 3, the resulting points can be visualized on a scatter plot.

Core theoretical contributions to MDS were made by James O. Ramsay of McGill University, who is also regarded as the founder of functional data analysis.

Types

MDS algorithms fall into a taxonomy, depending on the meaning of the input matrix:

Classical multidimensional scaling

It is also known as Principal Coordinates Analysis (PCoA), Torgerson Scaling or Torgerson–Gower scaling. It takes an input matrix giving dissimilarities between pairs of items and outputs a coordinate matrix whose configuration minimizes a loss function called strain,

Set up the squared proximity matrix D^{(2)}=[d_{ij}^2]

Apply double centering: B=-\frac{1}{2}CD^{(2)}C using the centering matrix C=I-\frac{1}{n}J_n, where n is the number of objects, I is the n \times n identity matrix, and J_{n} is an n\times n matrix of all ones.

Determine the m largest eigenvalues \lambda_1,\lambda_2,...,\lambda_m and corresponding eigenvectors e_1,e_2,...,e_m of B (where m is the number of dimensions desired for the output).

Now, X=E_m\Lambda_m^{1/2} , where E_m is the matrix of m eigenvectors and \Lambda_m is the diagonal matrix of m eigenvalues of B.

Classical MDS assumes metric distances. So this is not applicable for direct dissimilarity ratings.

Metric multidimensional scaling (mMDS)

It is a superset of classical MDS that generalizes the optimization procedure to a variety of loss functions and input matrices of known distances with weights and so on.  A useful loss function in this context is called stress, which is often minimized using a procedure called stress majorization. Metric MDS minimizes the cost function called “stress” which is a residual sum of squares:\text{Stress}_D(x_1,x_2,...,x_n)=\sqrt{\sum_{i\ne j=1,...,n}\bigl(d_{ij}-\|x_i-x_j\|\bigr)^2}.

Metric scaling uses a power transformation with a user-controlled exponent p: d_{ij}^p and -d_{ij}^{2p} for distance. In classical scaling p=1. Non-metric scaling is defined by the use of isotonic regression to nonparametrically estimate a transformation of the dissimilarities.

Non-metric multidimensional scaling (NMDS)

In contrast to metric MDS, non-metric MDS finds both a non-parametric monotonic relationship between the dissimilarities in the item-item matrix and the Euclidean distances between items, and the location of each item in the low-dimensional space.

Let d_{ij} be the dissimilarity between points i, j. Let \hat d_{ij} = \| x_i - x_j\| be the Euclidean distance between embedded points x_i, x_j.

Now, for each choice of the embedded points x_i and is a monotonically increasing function f, define the "stress" function:

S(x_1, ..., x_n; f)=\sqrt{\frac{\sum_{i

The factor of \sum_{i in the denominator is necessary to prevent a "collapse". Suppose we define instead S=\sqrt{\sum_{i, then it can be trivially minimized by setting f = 0, then collapse every point to the same point.

A few variants of this cost function exist. MDS programs automatically minimize stress in order to obtain the MDS solution.

The core of a non-metric MDS algorithm is a twofold optimization process. First the optimal monotonic transformation of the proximities has to be found. Secondly, the points of a configuration have to be optimally arranged, so that their distances match the scaled proximities as closely as possible.

NMDS needs to optimize two objectives simultaneously. This is usually done iteratively:

Initialize x_i randomly, e. g. by sampling from a normal distribution.

Do until a stopping criterion (for example, S )

Solve for f = \arg\min_f S(x_1, ..., x_n ; f) by isotonic regression.

Solve for x_1, ..., x_n = \arg\min_{x_1, ..., x_n}  S(x_1, ..., x_n ; f) by gradient descent or other methods.

Return x_i and f

Louis Guttman's smallest space analysis (SSA) is an example of a non-metric MDS procedure.

Generalized multidimensional scaling (GMD)

An extension of metric multidimensional scaling, in which the target space is an arbitrary smooth non-Euclidean space. In cases where the dissimilarities are distances on a surface and the target space is another surface, GMDS allows finding the minimum-distortion embedding of one surface into another.

Super multidimensional scaling (SMDS)

An extension of MDS, known as Super MDS, incorporates both distance and angle information for improved source localization. Unlike traditional MDS, which uses only distance measurements, Super MDS processes both distance and angle-of-arrival (AOA) data algebraically (without iteration) to achieve better accuracy.

The method proceeds in the following steps:

Construct the Reduced Edge Gram Kernel: For a network of N sources in an \eta-dimensional space, define the edge vectors as v_{i} = x_{m} - x_{n}. The dissimilarity is given by k_{i,j} = \langle v_i, v_j \rangle. Assemble these into the full kernel K = VV^T, and then form the reduced kernel using the N-1 independent vectors: \bar{K} = [V]_{(N-1)\times\eta}\ [V]_{(N-1)\times\eta}^T,

Eigen-Decomposition: Compute the eigen-decomposition of \bar{K},

Estimate Edge Vectors: Recover the edge vectors as  \hat{V} = \Bigl( U_{M \times \eta}\, \Lambda^{\odot \frac{1}{2}}_{\eta \times \eta} \Bigr)^T ,

Procrustes Alignment:  Retrieve \hat{V} from V via Procrustes Transformation,

Compute Coordinates: Solve the following linear equations to compute the coordinate estimates \begin{pmatrix}

1 \vline \mathbf{0}_{1 \times N-1} \\

\hline

\mathbf{[C]}_{N-1 \times N}

\end{pmatrix} \cdot \begin{pmatrix}\mathbf{x}_{1} \\

\hline[\mathbf{X}]_{N-1 \times \eta}

\end{pmatrix}=\begin{pmatrix}

\mathbf{x}_{1} \\

\hline[\mathbf{V}]_{N-1 \times \eta}

\end{pmatrix},

This concise approach reduces the need for multiple anchors and enhances localization precision by leveraging angle constraints.

Details

The data to be analyzed is a collection of M objects (colors, faces, stocks,&nbsp;.&nbsp;.&nbsp;.) on which a distance function is defined,

d_{i,j} := distance between i-th and j-th objects.

These distances are the entries of the dissimilarity matrix

D :=

\begin{pmatrix}

d_{1,1} & d_{1,2} & \cdots & d_{1,M} \\

d_{2,1} & d_{2,2} & \cdots & d_{2,M} \\

\vdots & \vdots & & \vdots \\

d_{M,1} & d_{M,2} & \cdots & d_{M,M}

\end{pmatrix}.

The goal of MDS is, given D, to find M vectors

x_1,\ldots,x_M \in \mathbb{R}^N such that

\|x_i - x_j\| \approx d_{i,j} for all i,j\in {1,\dots,M},

where \|\cdot\| is a vector norm.  In classical MDS, this norm is the Euclidean distance, but, in a broader sense, it may be a metric or arbitrary distance function.  For example, when dealing with mixed-type data that contain numerical as well as categorical descriptors, Gower's distance is a common alternative.

In other words, MDS attempts to find a mapping from the M objects into \mathbb{R}^N such that distances are preserved.  If the dimension N is chosen to be 2 or 3, we may plot the vectors x_i to obtain a visualization of the similarities between the M objects.  Note that the vectors x_i are not unique: With the Euclidean distance, they may be arbitrarily translated, rotated, and reflected, since these transformations do not change the pairwise distances \|x_i - x_j\|.

(Note: The symbol \mathbb{R} indicates the set of real numbers, and the notation \mathbb{R}^N refers to the Cartesian product of N copies of \mathbb{R}, which is an N-dimensional vector space over the field of the real numbers.)

There are various approaches to determining the vectors x_i.  Usually, MDS is formulated as an optimization problem, where (x_1,\ldots,x_M) is found as a minimizer of some cost function, for example,

\underset{x_1,\ldots,x_M}{\mathrm{argmin}} \sum_{i

A solution may then be found by numerical optimization techniques.  For some particularly chosen cost functions, minimizers can be stated analytically in terms of matrix eigendecompositions. (which deals with ordinal data).

Decide number of dimensions – The researcher must decide on the number of dimensions they want the computer to create. Interpretability of the MDS solution is often important, and lower dimensional solutions will typically be easier to interpret and visualize. However, dimension selection is also an issue of balancing underfitting and overfitting. Lower dimensional solutions may underfit by leaving out important dimensions of the dissimilarity data. Higher dimensional solutions may overfit to noise in the dissimilarity measurements. Model selection tools like AIC, BIC, Bayes factors, or cross-validation can thus be useful to select the dimensionality that balances underfitting and overfitting.

Mapping the results and defining the dimensions – The statistical program (or a related module) will map the results. The map will plot each product (usually in two-dimensional space). The proximity of products to each other indicate either how similar they are or how preferred they are, depending on which approach was used. How the dimensions of the embedding actually correspond to dimensions of system behavior, however, are not necessarily obvious. Here, a subjective judgment about the correspondence can be made (see perceptual mapping).

Test the results for reliability and validity – Compute R-squared to determine what proportion of variance of the scaled data can be accounted for by the MDS procedure. An R-square of 0.6 is considered the minimum acceptable level.  An R-square of 0.8 is considered good for metric scaling and .9 is considered good for non-metric scaling. Other possible tests are Kruskal’s Stress, split data tests, data stability tests (i.e., eliminating one brand), and test-retest reliability.

Report the results comprehensively – Along with the mapping, at least distance measure (e.g., Sorenson index, Jaccard index) and reliability (e.g., stress value) should be given. It is also very advisable to give the algorithm (e.g., Kruskal, Mather), which is often defined by the program used (sometimes replacing the algorithm report), if you have given a start configuration or had a random choice, the number of runs, the assessment of dimensionality, the Monte Carlo method results, the number of iterations, the assessment of stability, and the proportional variance of each axis (r-square).

Implementations

ELKI includes two MDS implementations.

MATLAB includes two MDS implementations (for classical (cmdscale) and non-classical (mdscale) MDS respectively).

The R programming language offers several MDS implementations, e.g. base cmdscale function, packages smacof (mMDS and nMDS), and vegan (weighted MDS).

scikit-learn contains function sklearn.manifold.MDS.

See also

Data clustering

t-distributed stochastic neighbor embedding

Factor analysis

Discriminant analysis

Dimensionality reduction

Distance geometry

Cayley–Menger determinant

Sammon mapping

Iconography of correlations

References

Bibliography

Category:Dimension reduction

Category:Quantitative marketing research

Category:Psychometrics