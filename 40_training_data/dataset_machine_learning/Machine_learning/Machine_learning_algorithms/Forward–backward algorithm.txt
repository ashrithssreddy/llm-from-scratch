The forward–backward algorithm is an  inference algorithm for hidden Markov models which computes the posterior marginals of all hidden state variables given a sequence of observations/emissions o_{1:T}:= o_1,\dots,o_T, i.e. it computes, for all hidden state variables X_t \in \{X_1, \dots, X_T\}, the distribution P(X_t\ |\ o_{1:T}). This inference task is usually called smoothing. The algorithm makes use of the principle of dynamic programming to efficiently compute the values that are required to obtain the posterior marginal distributions in two passes. The first pass goes forward in time while the second goes backward in time; hence the name forward–backward algorithm.

The term forward–backward algorithm is also used to refer to any algorithm belonging to the general class of algorithms that operate on sequence models in a forward–backward manner. In this sense, the descriptions in the remainder of this article refer only to one specific instance of this class.

Overview

In the first pass, the forward–backward algorithm computes a set of forward probabilities which provide, for all t \in \{1, \dots, T\}, the probability of ending up in any particular state given the first t observations in the sequence, i.e. P(X_t\ |\  o_{1:t}). In the second pass, the algorithm computes a set of backward probabilities which provide the probability of observing the remaining observations given any starting point t, i.e. P(o_{t+1:T}\ |\ X_t).  These two sets of probability distributions can then be combined to obtain the distribution over states at any specific point in time given the entire observation sequence:

P(X_t\ |\ o_{1:T}) = P(X_t\ |\ o_{1:t}, o_{t+1:T}) \propto P(o_{t+1:T}\ |\ X_t) P( X_t | o_{1:t})

The last step follows from an application of the Bayes' rule and the conditional independence of o_{t+1:T} and o_{1:t} given X_t.

As outlined above, the algorithm involves three steps:

computing forward probabilities

computing backward probabilities

computing smoothed values.

The forward and backward steps may also be called "forward message pass" and "backward message pass" - these terms are due to the message-passing used in general belief propagation approaches. At each single observation in the sequence, probabilities to be used for calculations at the next observation are computed. The smoothing step can be calculated simultaneously during the backward pass. This step allows the algorithm to take into account any past observations of output for computing more accurate results.

The forward–backward algorithm can be used to find the most likely state for any point in time. It cannot, however, be used to find the most likely sequence of states (see Viterbi algorithm).

Forward probabilities

The following description will use matrices of probability values instead of probability distributions. However, it is important to note that the forward-backward algorithm can generally be applied to both continuous and discrete probability models.

We transform the probability distributions related to a given hidden Markov model into matrix notation as follows.

The transition probabilities \mathbf{P}(X_t\mid X_{t-1}) of a given random variable X_t representing all possible states in the hidden Markov model will be represented by the matrix \mathbf{T} where the column index j will represent the target state and the row index i represents the start state. A transition from row-vector state \mathbf{\pi_t} to the incremental row-vector state \mathbf{\pi_{t+1}} is written as \mathbf{\pi_{t+1}} = \mathbf{\pi_{t}} \mathbf{T}. The example below represents a system where the probability of staying in the same state after each step is 70% and the probability of transitioning to the other state is 30%.  The transition matrix is then:

\mathbf{T} = \begin{pmatrix}

0.7 & 0.3 \\

0.3 & 0.7

\end{pmatrix}

In a typical Markov model, we would multiply a state vector by this matrix to obtain the probabilities for the subsequent state.  In a hidden Markov model the state is unknown, and we instead observe events associated with the possible states.  An event matrix of the form:

\mathbf{B} = \begin{pmatrix}

0.9 & 0.1 \\

0.2 & 0.8

\end{pmatrix}

provides the probabilities for observing events given a particular state.  In the above example, event 1 will be observed 90% of the time if we are in state 1 while event 2 has a 10% probability of occurring in this state.  In contrast, event 1 will only be observed 20% of the time if we are in state 2 and event 2 has an 80% chance of occurring.  Given an arbitrary row-vector describing the state of the system (\mathbf{\pi}), the probability of observing event j is then:

\mathbf{P}(O = j)=\sum_{i} \pi_i B_{i,j}

The probability of a given state leading to the observed event j can be represented in matrix form by multiplying the state row-vector (\mathbf{\pi}) with an observation matrix (\mathbf{O_j} = \mathrm{diag}(B_{*,o_j})) containing only diagonal entries. Continuing the above example, the observation matrix for event 1 would be:

\mathbf{O_1} = \begin{pmatrix}

0.9 & 0.0 \\

0.0 & 0.2

\end{pmatrix}

This allows us to calculate the new unnormalized probabilities state vector \mathbf{\pi '} through Bayes rule, weighting by the likelihood that each element of \mathbf{\pi} generated event 1 as:

\mathbf{\pi '} = \mathbf{\pi} \mathbf{O_1}

We can now make this general procedure specific to our series of observations. Assuming an initial state vector \mathbf{\pi}_0, (which can be optimized as a parameter through repetitions of the forward-backward procedure), we begin with \mathbf{f_{0:0}} = \mathbf{\pi}_0,  then updating the state distribution and weighting by the likelihood of the first observation:

\mathbf{f_{0:1}} = \mathbf{\pi}_0 \mathbf{T} \mathbf{O_{o_1}}

This process can be carried forward with additional observations using:

\mathbf{f_{0:t}} = \mathbf{f_{0:t-1}} \mathbf{T} \mathbf{O_{o_t}}

This value is the forward unnormalized probability vector.  The i'th entry of this vector provides:

\mathbf{f_{0:t}}(i) = \mathbf{P}(o_1, o_2, \dots, o_t, X_t=x_i | \mathbf{\pi}_0 )

Typically, we will normalize the probability vector at each step so that its entries sum to 1.  A scaling factor is thus introduced at each step such that:

\mathbf{\hat{f}_{0:t}} = c_t^{-1}\ \mathbf{\hat{f}_{0:t-1}} \mathbf{T} \mathbf{O_{o_t}}

where \mathbf{\hat{f}_{0:t-1}} represents the scaled vector from the previous step and c_t represents the scaling factor that causes the resulting vector's entries to sum to 1.  The product of the scaling factors is the total probability for observing the given events irrespective of the final states:

\mathbf{P}(o_1, o_2, \dots, o_t|\mathbf{\pi}_0) = \prod_{s=1}^t c_s

This allows us to interpret the scaled probability vector as:

\mathbf{\hat{f}_{0:t}}(i) =

\frac{\mathbf{f_{0:t}}(i)}{\prod_{s=1}^t c_s} =

\frac{\mathbf{P}(o_1, o_2, \dots, o_t, X_t=x_i | \mathbf{\pi}_0 )}{\mathbf{P}(o_1, o_2, \dots, o_t|\mathbf{\pi}_0)} =

\mathbf{P}(X_t=x_i | o_1, o_2, \dots, o_t, \mathbf{\pi}_0 )

We thus find that the product of the scaling factors provides us with the total probability for observing the given sequence up to time t and that the scaled probability vector provides us with the probability of being in each state at this time.

Backward probabilities

A similar procedure can be constructed to find backward probabilities.  These intend to provide the probabilities:

\mathbf{b_{t:T}}(i) = \mathbf{P}(o_{t+1}, o_{t+2}, \dots, o_{T} | X_t=x_i )

That is, we now want to assume that we start in a particular state (X_t=x_i), and we are now interested in the probability of observing all future events from this state.  Since the initial state is assumed as given (i.e. the prior probability of this state = 100%), we begin with:

\mathbf{b_{T:T}} = [1\ 1\ 1\ \dots]^T

Notice that we are now using a column vector while the forward probabilities used row vectors.  We can then work backwards using:

\mathbf{b_{t-1:T}} = \mathbf{T}\mathbf{O_t}\mathbf{b_{t:T}}

While we could normalize this vector as well so that its entries sum to one, this is not usually done.  Noting that each entry contains the probability of the future event sequence given a particular initial state, normalizing this vector would be equivalent to applying Bayes' theorem to find the likelihood of each initial state given the future events (assuming uniform priors for the final state vector).  However, it is more common to scale this vector using the same c_t constants used in the forward probability calculations.  \mathbf{b_{T:T}} is not scaled, but subsequent operations use:

\mathbf{\hat{b}_{t-1:T}} = c_t^{-1} \mathbf{T}\mathbf{O_t}\mathbf{\hat{b}_{t:T}}

where \mathbf{\hat{b}_{t:T}} represents the previous, scaled vector.  This result is that the scaled probability vector is related to the backward probabilities by:

\mathbf{\hat{b}_{t:T}}(i) =

\frac{\mathbf{b_{t:T}}(i)}{\prod_{s=t+1}^T c_s}

This is useful because it allows us to find the total probability of being in each state at a given time, t, by multiplying these values:

\mathbf{\gamma_t}(i) =

\mathbf{P}(X_t=x_i | o_1, o_2, \dots, o_T, \mathbf{\pi}_0) =

\frac{ \mathbf{P}(o_1, o_2, \dots, o_T, X_t=x_i | \mathbf{\pi}_0 ) }{ \mathbf{P}(o_1, o_2, \dots, o_T | \mathbf{\pi}_0 ) } =

\frac{ \mathbf{f_{0:t}}(i) \cdot \mathbf{b_{t:T}}(i) }{ \prod_{s=1}^T c_s } =

\mathbf{\hat{f}_{0:t}}(i) \cdot \mathbf{\hat{b}_{t:T}}(i)

To understand this, we note that \mathbf{f_{0:t}}(i) \cdot \mathbf{b_{t:T}}(i) provides the probability for observing the given events in a way that passes through state x_i at time t.  This probability includes the forward probabilities covering all events up to time t as well as the backward probabilities which include all future events.  This is the numerator we are looking for in our equation, and we divide by the total probability of the observation sequence to normalize this value and extract only the probability that X_t=x_i.  These values are sometimes called the "smoothed values" as they combine the forward and backward probabilities to compute a final probability.

The values \mathbf{\gamma_t}(i) thus provide the probability of being in each state at time t.  As such, they are useful for determining the most probable state at any time. The term "most probable state" is somewhat ambiguous.  While the most probable state is the most likely to be correct at a given point, the sequence of individually probable states is not likely to be the most probable sequence.  This is because the probabilities for each point are calculated independently of each other. They do not take into account the transition probabilities between states, and it is thus possible to get states at two moments (t and t+1) that are both most probable at those time points but which have very little probability of occurring together, i.e.  \mathbf{P}(X_t=x_i,X_{t+1}=x_j) \neq \mathbf{P}(X_t=x_i) \mathbf{P}(X_{t+1}=x_j) . The most probable sequence of states that produced an observation sequence can be found using the Viterbi algorithm.

Example

This example takes as its basis the umbrella world in Russell & Norvig 2010 Chapter 15 pp. 567 in which we would like to infer the weather given observation of another person either carrying or not carrying an umbrella.  We assume two possible states for the weather: state 1 = rain, state 2 = no rain.  We assume that the weather has a 70% chance of staying the same each day and a 30% chance of changing.  The transition probabilities are then:

\mathbf{T} = \begin{pmatrix}

0.7 & 0.3 \\

0.3 & 0.7

\end{pmatrix}

We also assume each state generates one of two possible events: event 1 = umbrella, event 2 = no umbrella.  The conditional probabilities for these occurring in each state are given by the probability matrix:

\mathbf{B} = \begin{pmatrix}

0.9 & 0.1 \\

0.2 & 0.8

\end{pmatrix}

We then observe the following sequence of events: {umbrella, umbrella, no umbrella, umbrella, umbrella} which we will represent in our calculations as:

\mathbf{O_1} = \begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}~~\mathbf{O_2} = \begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}~~\mathbf{O_3} = \begin{pmatrix}0.1 & 0.0 \\  0.0 & 0.8 \end{pmatrix}~~\mathbf{O_4} = \begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}~~\mathbf{O_5} = \begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}

Note that \mathbf{O_3} differs from the others because of the "no umbrella" observation.

In computing the forward probabilities we begin with:

\mathbf{f_{0:0}}= \begin{pmatrix}  0.5 & 0.5 \end{pmatrix}

which is our prior state vector indicating that we don't know which state the weather is in before our observations.  While a state vector should be given as a row vector, we will use the transpose of the matrix so that the calculations below are easier to read.  Our calculations are then written in the form:

(\mathbf{\hat{f}_{0:t}})^T = c_t^{-1}\mathbf{O_t}(\mathbf{T})^T(\mathbf{\hat{f}_{0:t-1}})^T

instead of:

\mathbf{\hat{f}_{0:t}} = c_t^{-1}\mathbf{\hat{f}_{0:t-1}} \mathbf{T} \mathbf{O_t}

Notice that the transformation matrix is also transposed, but in our example the transpose is equal to the original matrix.  Performing these calculations and normalizing the results provides:

(\mathbf{\hat{f}_{0:1}})^T =

c_1^{-1}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.5000 \\ 0.5000 \end{pmatrix}=

c_1^{-1}\begin{pmatrix}0.4500 \\ 0.1000\end{pmatrix}=

\begin{pmatrix}0.8182 \\ 0.1818 \end{pmatrix}

(\mathbf{\hat{f}_{0:2}})^T =

c_2^{-1}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.8182 \\ 0.1818 \end{pmatrix}=

c_2^{-1}\begin{pmatrix}0.5645 \\ 0.0745\end{pmatrix}=

\begin{pmatrix}0.8834 \\ 0.1166 \end{pmatrix}

(\mathbf{\hat{f}_{0:3}})^T =

c_3^{-1}\begin{pmatrix}0.1 & 0.0 \\  0.0 & 0.8 \end{pmatrix}\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.8834 \\ 0.1166 \end{pmatrix}=

c_3^{-1}\begin{pmatrix}0.0653 \\ 0.2772\end{pmatrix}=

\begin{pmatrix}0.1907 \\ 0.8093 \end{pmatrix}

(\mathbf{\hat{f}_{0:4}})^T =

c_4^{-1}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.1907 \\ 0.8093 \end{pmatrix}=

c_4^{-1}\begin{pmatrix}0.3386 \\ 0.1247\end{pmatrix}=

\begin{pmatrix}0.7308 \\ 0.2692 \end{pmatrix}

(\mathbf{\hat{f}_{0:5}})^T =

c_5^{-1}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.7308 \\ 0.2692 \end{pmatrix}=

c_5^{-1}\begin{pmatrix}0.5331 \\ 0.0815\end{pmatrix}=

\begin{pmatrix}0.8673 \\ 0.1327 \end{pmatrix}

For the backward probabilities, we start with:

\mathbf{b_{5:5}} = \begin{pmatrix}  1.0 \\ 1.0\end{pmatrix}

We are then able to compute (using the observations in reverse order and normalizing with different constants):

\mathbf{\hat{b}_{4:5}}  = \alpha\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}1.0000 \\ 1.0000 \end{pmatrix}=\alpha\begin{pmatrix}0.6900 \\ 0.4100\end{pmatrix}=\begin{pmatrix}0.6273 \\ 0.3727 \end{pmatrix}

\mathbf{\hat{b}_{3:5}}  = \alpha\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}0.6273 \\ 0.3727 \end{pmatrix}=\alpha\begin{pmatrix}0.4175 \\ 0.2215\end{pmatrix}=\begin{pmatrix}0.6533 \\ 0.3467 \end{pmatrix}

\mathbf{\hat{b}_{2:5}}  = \alpha\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.1 & 0.0 \\  0.0 & 0.8 \end{pmatrix}\begin{pmatrix}0.6533 \\ 0.3467 \end{pmatrix}=\alpha\begin{pmatrix}0.1289 \\ 0.2138\end{pmatrix}=\begin{pmatrix}0.3763 \\ 0.6237 \end{pmatrix}

\mathbf{\hat{b}_{1:5}}  = \alpha\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}0.3763 \\ 0.6237 \end{pmatrix}=\alpha\begin{pmatrix}0.2745 \\ 0.1889\end{pmatrix}=\begin{pmatrix}0.5923 \\ 0.4077 \end{pmatrix}

\mathbf{\hat{b}_{0:5}}  = \alpha\begin{pmatrix}  0.7 & 0.3 \\  0.3 & 0.7 \end{pmatrix}\begin{pmatrix}0.9 & 0.0 \\  0.0 & 0.2 \end{pmatrix}\begin{pmatrix}0.5923 \\ 0.4077 \end{pmatrix}=\alpha\begin{pmatrix}0.3976 \\ 0.2170\end{pmatrix}=\begin{pmatrix}0.6469 \\ 0.3531 \end{pmatrix}

Finally, we will compute the smoothed probability values.  These results must also be scaled so that its entries sum to 1 because we did not scale the backward probabilities with the c_t's found earlier.  The backward probability vectors above thus actually represent the likelihood of each state at time t given the future observations.  Because these vectors are proportional to the actual backward probabilities, the result has to be scaled an additional time.

(\mathbf{\gamma_0})^T  = \alpha\begin{pmatrix}0.5000 \\ 0.5000 \end{pmatrix}\circ \begin{pmatrix}0.6469 \\ 0.3531 \end{pmatrix}=\alpha\begin{pmatrix}0.3235 \\ 0.1765\end{pmatrix}=\begin{pmatrix}0.6469 \\ 0.3531 \end{pmatrix}

(\mathbf{\gamma_1})^T  = \alpha\begin{pmatrix}0.8182 \\ 0.1818 \end{pmatrix}\circ \begin{pmatrix}0.5923 \\ 0.4077 \end{pmatrix}=\alpha\begin{pmatrix}0.4846 \\ 0.0741\end{pmatrix}=\begin{pmatrix}0.8673 \\ 0.1327 \end{pmatrix}

(\mathbf{\gamma_2})^T  = \alpha\begin{pmatrix}0.8834 \\ 0.1166 \end{pmatrix}\circ \begin{pmatrix}0.3763 \\ 0.6237 \end{pmatrix}=\alpha\begin{pmatrix}0.3324 \\ 0.0728\end{pmatrix}=\begin{pmatrix}0.8204 \\ 0.1796 \end{pmatrix}

(\mathbf{\gamma_3})^T  = \alpha\begin{pmatrix}0.1907 \\ 0.8093 \end{pmatrix}\circ \begin{pmatrix}0.6533 \\ 0.3467 \end{pmatrix}=\alpha\begin{pmatrix}0.1246 \\ 0.2806\end{pmatrix}=\begin{pmatrix}0.3075 \\ 0.6925 \end{pmatrix}

(\mathbf{\gamma_4})^T  = \alpha\begin{pmatrix}0.7308 \\ 0.2692 \end{pmatrix}\circ \begin{pmatrix}0.6273 \\ 0.3727 \end{pmatrix}=\alpha\begin{pmatrix}0.4584 \\ 0.1003\end{pmatrix}=\begin{pmatrix}0.8204 \\ 0.1796 \end{pmatrix}

(\mathbf{\gamma_5})^T  = \alpha\begin{pmatrix}0.8673 \\ 0.1327 \end{pmatrix}\circ \begin{pmatrix}1.0000 \\ 1.0000 \end{pmatrix}=\alpha\begin{pmatrix}0.8673 \\ 0.1327 \end{pmatrix}=\begin{pmatrix}0.8673 \\ 0.1327 \end{pmatrix}

Notice that the value of \mathbf{\gamma_0} is equal to \mathbf{\hat{b}_{0:5}} and that \mathbf{\gamma_5} is equal to \mathbf{\hat{f}_{0:5}}.  This follows naturally because both \mathbf{\hat{f}_{0:5}} and \mathbf{\hat{b}_{0:5}} begin with uniform priors over the initial and final state vectors (respectively) and take into account all of the observations.  However, \mathbf{\gamma_0} will only be equal to \mathbf{\hat{b}_{0:5}} when our initial state vector represents a uniform prior (i.e. all entries are equal).  When this is not the case \mathbf{\hat{b}_{0:5}} needs to be combined with the initial state vector to find the most likely initial state.  We thus find that the forward probabilities by themselves are sufficient to calculate the most likely final state.  Similarly, the backward probabilities can be combined with the initial state vector to provide the most probable initial state given the observations.  The forward and backward probabilities need only be combined to infer the most probable states between the initial and final points.

The calculations above reveal that the most probable weather state on every day except for the third one was "rain".  They tell us more than this, however, as they now provide a way to quantify the probabilities of each state at different times.  Perhaps most importantly, our value at \mathbf{\gamma_5} quantifies our knowledge of the state vector at the end of the observation sequence.  We can then use this to predict the probability of the various weather states tomorrow as well as the probability of observing an umbrella.

Performance

The forward–backward algorithm runs with time complexity  O(S^2 T)  in space  O(S T) , where T is the length of the time sequence and S is the number of symbols in the state alphabet.  The algorithm can also run in constant space with time complexity  O(S^2 T^2)  by recomputing values at each step. For comparison, a brute-force procedure would generate all possible S^T state sequences and calculate the joint probability of each state sequence with the observed series of events, which would have time complexity  O(T \cdot S^T) . Brute force is intractable for realistic problems, as the number of possible hidden node sequences typically is extremely high.

An enhancement to the general forward-backward algorithm, called the Island algorithm, trades smaller memory usage for longer running time, taking  O(S^2 T \log T)  time and  O(S \log T)  memory. Furthermore, it is possible to invert the process model to obtain an O(S) space, O(S^2 T) time algorithm, although the inverted process may not exist or be ill-conditioned.

In addition, algorithms have been developed to compute \mathbf{f_{0:t+1}} efficiently through online smoothing such as the fixed-lag smoothing (FLS) algorithm.

Pseudocode

algorithm forward_backward is

input: guessState

int sequenceIndex

output: result

if sequenceIndex is past the end of the sequence then

return 1

if (guessState, sequenceIndex) has been seen before then

return saved result

result := 0

for each neighboring state n:

result := result + (transition probability from guessState to

n given observation element at sequenceIndex)

× Backward(n, sequenceIndex + 1)

save result for (guessState, sequenceIndex)

return result

Python example

Given HMM (just like in Viterbi algorithm) represented in the Python programming language:

states = ("Healthy", "Fever")

end_state = "E"

observations = ("normal", "cold", "dizzy")

start_probability = {"Healthy": 0.6, "Fever": 0.4}

transition_probability = {

"Healthy": {"Healthy": 0.69, "Fever": 0.3, "E": 0.01},

"Fever": {"Healthy": 0.4, "Fever": 0.59, "E": 0.01},

}

emission_probability = {

"Healthy": {"normal": 0.5, "cold": 0.4, "dizzy": 0.1},

"Fever": {"normal": 0.1, "cold": 0.3, "dizzy": 0.6},

}

We can write the implementation of the forward-backward algorithm like this:

def fwd_bkw(observations, states, start_prob, trans_prob, emm_prob, end_st):

"""Forward–backward algorithm."""

# Forward part of the algorithm

fwd = []

for i, observation_i in enumerate(observations):

f_curr = {}

for st in states:

if i == 0:

# base case for the forward part

prev_f_sum = start_prob[st]

else:

prev_f_sum = sum(f_prev[k] * trans_prob[k][st] for k in states)

f_curr[st] = emm_prob[st][observation_i] * prev_f_sum

fwd.append(f_curr)

f_prev = f_curr

p_fwd = sum(f_curr[k] * trans_prob[k][end_st] for k in states)

# Backward part of the algorithm

bkw = []

for i, observation_i_plus in enumerate(reversed(observations[1:] + (None,))):

b_curr = {}

for st in states:

if i == 0:

# base case for backward part

b_curr[st] = trans_prob[st][end_st]

else:

b_curr[st] = sum(trans_prob[st][l] * emm_prob[l][observation_i_plus] * b_prev[l] for l in states)

bkw.insert(0,b_curr)

b_prev = b_curr

p_bkw = sum(start_prob[l] * emm_prob[l][observations] * b_curr[l] for l in states)

# Merging the two parts

posterior = []

for i in range(len(observations)):

posterior.append({st: fwd[i][st] * bkw[i][st] / p_fwd for st in states})

assert p_fwd == p_bkw

return fwd, bkw, posterior

The function fwd_bkw takes the following arguments:

x is the sequence of observations, e.g. ['normal', 'cold', 'dizzy'];

states is the set of hidden states;

a_0 is the start probability;

a are the transition probabilities;

and e are the emission probabilities.

For simplicity of code, we assume that the observation sequence x is non-empty and that  a[i][j] and e[i][j] is defined for all states i,j.

In the running example, the forward-backward algorithm is used as follows:

def example():

return fwd_bkw(

observations,

states,

start_probability,

transition_probability,

emission_probability,

end_state,

)

>>> for line in example():

...     print(*line)

...

{'Healthy': 0.3, 'Fever': 0.04000000000000001} {'Healthy': 0.0892, 'Fever': 0.03408} {'Healthy': 0.007518, 'Fever': 0.028120319999999997}

{'Healthy': 0.0010418399999999998, 'Fever': 0.00109578} {'Healthy': 0.00249, 'Fever': 0.00394} {'Healthy': 0.01, 'Fever': 0.01}

{'Healthy': 0.8770110375573259, 'Fever': 0.1229889624426741} {'Healthy': 0.623228030950954, 'Fever': 0.3767719690490461} {'Healthy': 0.2109527048413057, 'Fever': 0.7890472951586943}

See also

Baum–Welch algorithm

Viterbi algorithm

BCJR algorithm

References

Lawrence R. Rabiner, A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition. Proceedings of the IEEE, 77 (2), p.&nbsp;257–286, February 1989. 10.1109/5.18626

External links

An interactive spreadsheet for teaching the forward–backward algorithm (spreadsheet and article with step-by-step walk-through)

Tutorial of hidden Markov models including the forward–backward algorithm

Collection of AI algorithms implemented in Java (including HMM and the forward–backward algorithm)

Category:Articles with example Python (programming language) code

Category:Dynamic programming

Category:Error detection and correction

Category:Machine learning algorithms

Category:Markov models