Markov decision process (MDP), also called a stochastic dynamic program or stochastic control problem, is a model for sequential decision making when outcomes are uncertain.

Originating from operations research in the 1950s, MDPs have since gained recognition in a variety of fields, including ecology, economics, healthcare, telecommunications and reinforcement learning. Reinforcement learning utilizes the MDP framework to model the interaction between a learning agent and its environment. In this framework, the interaction is characterized by states, actions, and rewards. The MDP framework is designed to provide a simplified representation of key elements of artificial intelligence challenges. This modeling framework incorporates the understanding of cause and effect, the management of uncertainty and nondeterminism, and the pursuit of explicit goals. (Note that this is a different meaning from the term generative model in the context of statistical classification.) In algorithms that are expressed using pseudocode, G is often used to represent a generative model. For example, the expression s', r \gets G(s, a) might denote the action of sampling from the generative model where s and a are the current state and action, and s' and r are the new state and reward. Compared to an episodic simulator, a generative model has the advantage that it can yield data from any state, not only those encountered in a trajectory.

These model classes form a hierarchy of information content: an explicit model trivially yields a generative model through sampling from the distributions, and repeated application of a generative model yields an episodic simulator. In the opposite direction, it is only possible to learn approximate models through regression. The type of model available for a particular MDP plays a significant role in determining which solution algorithms are appropriate. For example, the dynamic programming algorithms described in the next section require an explicit model, and Monte Carlo tree search requires a generative model (or an episodic simulator that can be copied at any state), whereas most reinforcement learning algorithms require only an episodic simulator.

Example

)]]

An example of MDP is the Pole-Balancing model, which comes from classic control theory.

In this example, we have

S is the set of ordered tuples (\theta,\dot \theta, x, \dot x ) given by pole angle, angular velocity, position of the cart and its speed.

A is \{-1,1\}, corresponding to applying a force on the left (right) on the cart.

P_a(s, s') is the transition of the system, which in this case is going to be deterministic and driven by the laws of mechanics.

R_a(s, s') is 1 if the pole is up after the transition, zero otherwise. Therefore, this function only depend on s' in this specific case.

Algorithms

Solutions for MDPs with finite state and action spaces may be found through a variety of methods such as dynamic programming. The algorithms in this section apply to MDPs with finite state and action spaces and explicitly given transition probabilities and reward functions, but the basic concepts may be extended to handle other problem classes, for example using function approximation. Also, some processes with countably infinite state and action spaces can be exactly reduced to ones with finite state and action spaces.

The standard family of algorithms to calculate optimal policies for finite state and action MDPs requires storage for two arrays indexed by state: value V, which contains real values, and policy \pi, which contains actions. At the end of the algorithm, \pi will contain the solution and V(s) will contain the discounted sum of the rewards to be earned (on average) by following that solution from state s.

The algorithm has two steps, (1) a value update and (2) a policy update, which are repeated in some order for all the states until no further changes take place.  Both recursively update a new estimation of the optimal policy and state value using an older estimation of those values.

V(s) := \sum_{s'} P_{\pi(s)} (s,s') \left( R_{\pi(s)} (s,s') + \gamma V(s') \right)

\pi(s) := \operatorname{argmax}_a \left\{ \sum_{s'} P_{a}(s, s') \left( R_{a}(s,s') + \gamma V(s') \right) \right\}

Their order depends on the variant of the algorithm; one can also do them for all states at once or state by state, and more often to some states than others. As long as no state is permanently excluded from either of the steps, the algorithm will eventually arrive at the correct solution.

Notable variants

Value iteration

In value iteration , which is also called backward induction,

the \pi function is not used; instead, the value of \pi(s) is calculated within V(s) whenever it is needed. Substituting the calculation of \pi(s) into the calculation of V(s) gives the combined step;

V_{i+1}(s) := \max_a \left\{ \sum_{s'} P_a(s,s') \left( R_a(s,s') + \gamma V_i(s') \right) \right\},

where i is the iteration number. Value iteration starts at i = 0 and V_0 as a guess of the value function. It then iterates, repeatedly computing V_{i+1} for all states s, until V converges with the left-hand side equal to the right-hand side (which is the "Bellman equation" for this problem). Lloyd Shapley's 1953 paper on stochastic games included as a special case the value iteration method for MDPs, but this was recognized only later on.

Policy iteration

In policy iteration , step one is performed once, and then step two is performed once, then both are repeated until policy converges. Then step one is again performed once and so on. (Policy iteration was invented by Howard to optimize Sears catalogue mailing, which he had been optimizing using value iteration.)

Instead of repeating step two to convergence, it may be formulated and solved as a set of linear equations. These equations are merely obtained by making s = s' in the step two equation. Thus, repeating step two to convergence can be interpreted as solving the linear equations by relaxation.

This variant has the advantage that there is a definite stopping condition: when the array \pi does not change in the course of applying step 1 to all states, the algorithm is completed.

Policy iteration is usually slower than value iteration for a large number of possible states.

Modified policy iteration

In modified policy iteration (; ), step one is performed once, and then step two is repeated several times. Then step one is again performed once and so on.

Prioritized sweeping

In this variant, the steps are preferentially applied to states which are in some way important – whether based on the algorithm (there were large changes in V or \pi around those states recently) or based on use (those states are near the starting state, or otherwise of interest to the person or program using the algorithm).

Computational complexity

Algorithms for finding optimal policies with time complexity polynomial in the size of the problem representation exist for finite MDPs. Thus, decision problems based on MDPs are in computational complexity class P. However, due to the curse of dimensionality, the size of the problem representation is often exponential in the number of state and action variables, limiting exact solution techniques to problems that have a compact representation. In practice, online planning techniques such as Monte Carlo tree search can find useful solutions in larger problems, and, in theory, it is possible to construct online planning algorithms that can find an arbitrarily near-optimal policy with no computational complexity dependence on the size of the state space.

Extensions and generalizations

A Markov decision process is a stochastic game with only one player.

Partial observability

The solution above assumes that the state s is known when action is to be taken; otherwise \pi(s) cannot be calculated. When this assumption is not true, the problem is called a partially observable Markov decision process or POMDP.

Constrained Markov decision processes

Constrained Markov decision processes (CMDPS) are extensions to Markov decision process (MDPs). There are three fundamental differences between MDPs and CMDPs.

There are multiple costs incurred after applying an action instead of one.

CMDPs are solved with linear programs only, and dynamic programming does not work.

The final policy depends on the starting state.

The method of Lagrange multipliers applies to CMDPs.

Many Lagrangian-based algorithms have been developed.

Natural policy gradient primal-dual method.

There are a number of applications for CMDPs. It has recently been used in motion planning scenarios in robotics.

Continuous-time Markov decision process

In discrete-time Markov Decision Processes, decisions are made at discrete time intervals. However, for continuous-time Markov decision processes, decisions can be made at any time the decision maker chooses. In comparison to discrete-time Markov decision processes, continuous-time Markov decision processes can better model the decision-making process for a system that has continuous dynamics, i.e.,&nbsp;the system dynamics are defined by ordinary differential equations (ODEs). This modelling framework can be applied to areas such as queueing systems, epidemic processes, and population processes.

Like the discrete-time Markov decision processes, in continuous-time Markov decision processes the agent aims to find the optimal policy that would maximize the expected cumulative reward. The key difference with the standard case is that, due to the continuous nature of the time variable, summation is replaced by an integral:

\max \operatorname{E}_\pi\left[\left. \int_0^\infty\gamma^t r(s(t),\pi(s(t))) \, dt \;\right| s_0 \right]

where 0\leq\gamma

Discrete space: Linear programming formulation

If the state space and action space are finite, we could use linear programming to find the optimal policy, which was one of the earliest approaches applied. Here we only consider the ergodic model, which means our continuous-time MDP becomes an ergodic continuous-time Markov chain under a stationary policy. Under this assumption, although the decision maker can make a decision at any time in the current state, there is no benefit in taking multiple actions. It is better to take an action only at the time when system is transitioning from the current state to another state. Under some conditions, if our optimal value function V^* is independent of state i, we will have the following inequality:

g\geq R(i,a)+\sum_{j\in S}q(j\mid i,a)h(j) \quad \forall i \in S \text{ and } a \in A(i)

If there exists a function h, then \bar V^* will be the smallest g satisfying the above equation. In order to find \bar V^*, we could use the following linear programming model:

Primal linear program(P-LP)

\begin{align}

\text{Minimize}\quad &g\\

\text{s.t} \quad & g-\sum_{j \in S}q(j\mid i,a)h(j)\geq R(i,a)\,\,

\forall i\in S,\,a\in A(i)

\end{align}

Dual linear program(D-LP)

\begin{align}

\text{Maximize} &\sum_{i\in S}\sum_{a\in A(i)}R(i,a)y(i,a)\\

\text{s.t.} &\sum_{i\in S}\sum_{a\in A(i)} q(j\mid i,a)y(i,a)=0 \quad

\forall j\in S,\\

& \sum_{i\in S}\sum_{a\in A(i)}y(i,a)=1,\\

& y(i,a)\geq 0 \qquad \forall a\in A(i) \text{ and } \forall i\in S

\end{align}

y(i,a) is a feasible solution to the D-LP if y(i,a) is nonnative and satisfied the constraints in the D-LP problem. A feasible solution y^*(i,a) to the D-LP is said to be an optimal solution if

\begin{align}

\sum_{i\in S}\sum_{a\in A(i)}R(i,a)y^*(i,a) \geq  \sum_{i\in S} \sum_{a\in A(i)} R(i,a) y(i,a)

\end{align}

for all feasible solution y(i,a) to the D-LP. Once we have found the optimal solution y^*(i,a), we can use it to establish the optimal policies.

Continuous space: Hamilton–Jacobi–Bellman equation

In continuous-time MDP, if the state space and action space are continuous, the optimal criterion could be found by solving the Hamilton–Jacobi–Bellman (HJB) partial differential equation. In order to discuss the HJB equation, we need to reformulate

our problem

\begin{align} V(s(0),0)= {} & \max_{a(t)=\pi(s(t))}\int_0^T r(s(t),a(t)) \, dt+D[s(T)] \\

\text{s.t.}\quad & \frac{d s(t)}{dt}=f[t,s(t),a(t)]

\end{align}

D(\cdot) is the terminal reward function, s(t) is the system state vector, a(t) is the system control vector we try to find. f(\cdot) shows how the state vector changes over time. The Hamilton–Jacobi–Bellman equation is as follows:

0=\max_a ( r(t,s,a) +\frac{\partial V(t,s)}{\partial s}f(t,s,a))

We could solve the equation to find the optimal value function V^*, which in turns yield the optimal control at any time t, a(t) through

a(t)=\underset{a}{\text{argmax}} ( r(t,s,a) +\frac{\partial V^*(t,s)}{\partial s}f(t,s,a)).

Reinforcement learning

Reinforcement learning is an interdisciplinary area of machine learning and optimal control that has, as main objective, finding an approximately optimal policy for MDPs where transition probabilities and rewards are unknown.

Reinforcement learning can solve Markov-Decision processes without explicit specification of the transition probabilities which are instead needed to perform policy iteration. In this setting, transition probabilities and rewards must be learned from experience, i.e. by letting an agent interact with the MDP for a given number of steps. Both on a theoretical and on a practical level, effort is put in maximizing the sample efficiency, i.e. minimimizing the number of samples needed to learn a policy whose performance is \varepsilon-close to the optimal one (due to the stochastic nature of the process, learning the optimal policy with a finite number of samples is, in general, impossible).

Reinforcement Learning for discrete MDPs

For the purpose of this section, it is useful to define a further function, which corresponds to taking the action a and then continuing optimally (or according to whatever policy one currently has):

\ Q(s,a) = \sum_{s'} P_a(s,s') (R_a(s,s') + \gamma V(s')).\

While this function is also unknown, experience during learning is based on (s, a) pairs (together with the outcome s'; that is, "I was in state s and I tried doing a and s' happened"). Thus, one has an array Q and uses experience to update it directly. This is known as Q-learning.

Other scopes

Learning automata

Another application of MDP process in machine learning theory is called learning automata. This is also one type of reinforcement learning if the environment is stochastic. The first detail learning automata paper is surveyed by Narendra and Thathachar (1974), which were originally described explicitly as finite-state automata. Similar to reinforcement learning, a learning automata algorithm also has the advantage of solving the problem when probability or rewards are unknown. The difference between learning automata and Q-learning is that the former technique omits the memory of Q-values, but updates the action probability directly to find the learning result. Learning automata is a learning scheme with a rigorous proof of convergence.

In learning automata theory, a stochastic automaton consists of:

a set x of possible inputs,

a set Φ = { Φ1, ..., Φs } of possible internal states,

a set α = { α1, ..., αr } of possible outputs, or actions, with r ≤ s,

an initial state probability vector p(0) = ≪ p1(0), ..., ps(0) ≫,

a computable function A which after each time step t generates p(t + 1) from p(t), the current input, and the current state, and

a function G: Φ → α which generates the output at each time step.

The states of such an automaton correspond to the states of a "discrete-state discrete-parameter Markov process". At each time step t = 0,1,2,3,..., the automaton reads an input from its environment, updates P(t) to P(t + 1) by A, randomly chooses a successor state according to the probabilities P(t + 1) and outputs the corresponding action. The automaton's environment, in turn, reads the action and sends the next input to the automaton.

Category theoretic interpretation

Other than the rewards, a Markov decision process (S,A,P) can be understood in terms of Category theory. Namely, let \mathcal{A} denote the free monoid with generating set A. Let Dist denote the Kleisli category of the Giry monad. Then a functor \mathcal{A}\to\mathbf{Dist} encodes both the set S of states and the probability function P.

In this way, Markov decision processes could be generalized from monoids (categories with one object) to arbitrary categories. One can call the result (\mathcal{C}, F:\mathcal{C}\to \mathbf{Dist}) a context-dependent Markov decision process, because moving from one object to another in \mathcal{C} changes the set of available actions and the set of possible states.

Alternative notations

The terminology and notation for MDPs are not entirely settled. There are two main streams — one focuses on maximization problems from contexts like economics, using the terms action, reward, value, and calling the discount factor  or , while the other focuses on minimization problems from engineering and navigation, using the terms control, cost, cost-to-go, and calling the discount factor . In addition, the notation for the transition probability varies.

In addition, transition probability is sometimes written \Pr(s,a,s'), \Pr(s'\mid s,a) or, rarely, p_{s's}(a).

See also

Probabilistic automata

Odds algorithm

Quantum finite automata

Partially observable Markov decision process

Dynamic programming

Bellman equation for applications to economics.

Hamilton–Jacobi–Bellman equation

Optimal control

Recursive economics

Mabinogion sheep problem

Stochastic games

Q-learning

Markov chain

References

Sources

. Dover paperback edition (2003)

Further reading

Appendix contains abridged

Category:Optimal decisions

Category:Dynamic programming

Category:Markov processes

Category:Stochastic control