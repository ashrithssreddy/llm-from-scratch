In machine learning, normalization is a statistical technique with various applications. There are two main forms of normalization, namely data normalization and activation normalization. Data normalization (or feature scaling) includes methods that rescale input data so that the features have the same range, mean, variance, or other statistical properties. For instance, a popular choice of feature scaling method is min-max normalization, where each feature is transformed to have the same range (typically [0,1] or [-1,1]). This solves the problem of different features having vastly different scales, for example if one feature is measured in kilometers and another in nanometers.

Activation normalization, on the other hand, is specific to deep learning, and includes methods that rescale the activation of hidden neurons inside neural networks.

Normalization is often used to:

increase the speed of training convergence,

reduce sensitivity to variations and feature scales in input data,

reduce overfitting,

and produce better model generalization to unseen data.

Normalization techniques are often theoretically justified as reducing covariance shift, smoothing optimization landscapes, and increasing regularization, though they are mainly justified by empirical success.

Batch normalization

Batch normalization (BatchNorm) operates on the activations of a layer for each mini-batch.

Consider a simple feedforward network, defined by chaining together modules:

x^{(0)} \mapsto x^{(1)} \mapsto x^{(2)} \mapsto \cdots

where each network module can be a linear transform, a nonlinear activation function, a convolution, etc. x^{(0)} is the input vector, x^{(1)} is the output vector from the first module, etc.

BatchNorm is a module that can be inserted at any point in the feedforward network. For example, suppose it is inserted just after x^{(l)}, then the network would operate accordingly:

\cdots \mapsto x^{(l)} \mapsto \mathrm{BN}(x^{(l)}) \mapsto x^{(l+1)} \mapsto \cdots

The BatchNorm module does not operate over individual inputs. Instead, it must operate over one batch of inputs at a time.

Concretely, suppose we have a batch of inputs x^{(0)}_{(1)}, x^{(0)}_{(2)}, \dots, x^{(0)}_{(B)}, fed all at once into the network. We would obtain in the middle of the network some vectors:

x^{(l)}_{(1)}, x^{(l)}_{(2)}, \dots, x^{(l)}_{(B)}

The BatchNorm module computes the coordinate-wise mean and variance of these vectors:

\begin{aligned}

\mu^{(l)}_i &= \frac 1B \sum_{b=1}^B x^{(l)}_{(b), i} \\

(\sigma^{(l)}_i)^2 &= \frac{1}{B} \sum_{b=1}^B (x_{(b),i}^{(l)} - \mu_i^{(l)})^2

\end{aligned}

where i indexes the coordinates of the vectors, and b indexes the elements of the batch. In other words, we are considering the i-th coordinate of each vector in the batch, and computing the mean and variance of these numbers.

It then normalizes each coordinate to have zero mean and unit variance:

\hat{x}^{(l)}_{(b), i} = \frac{x^{(l)}_{(b), i} - \mu^{(l)}_i}{\sqrt{(\sigma^{(l)}_i)^2 + \epsilon}}

The \epsilon is a small positive constant such as 10^{-9} added to the variance for numerical stability, to avoid division by zero.

Finally, it applies a linear transformation:

y^{(l)}_{(b), i} = \gamma_i \hat{x}^{(l)}_{(b), i} + \beta_i

Here, \gamma and \beta are parameters inside the BatchNorm module. They are learnable parameters, typically trained by gradient descent.

The following is a Python implementation of BatchNorm:

import numpy as np

def batchnorm(x, gamma, beta, epsilon=1e-9):

# Mean and variance of each feature

mu = np.mean(x, axis=0)  # shape (N,)

var = np.var(x, axis=0)  # shape (N,)

# Normalize the activations

x_hat = (x - mu) / np.sqrt(var + epsilon)  # shape (B, N)

# Apply the linear transform

y = gamma * x_hat + beta  # shape (B, N)

return y

Interpretation

\gamma and \beta allow the network to learn to undo the normalization, if this is beneficial. BatchNorm can be interpreted as removing the purely linear transformations, so that its layers focus solely on modelling the nonlinear aspects of data, which may be beneficial, as a neural network can always be augmented with a linear transformation layer on top. and detractors.

Special cases

The original paper

Concretely, suppose we have a 2-dimensional convolutional layer defined by:

x^{(l)}_{h, w, c} = \sum_{h', w', c'} K^{(l)}_{h'-h, w'-w, c, c'} x_{h', w', c'}^{(l-1)} + b^{(l)}_c

where:

x^{(l)}_{h, w, c} is the activation of the neuron at position (h, w) in the c-th channel of the l-th layer.

K^{(l)}_{\Delta h, \Delta w, c, c'} is a kernel tensor. Each channel c corresponds to a kernel K^{(l)}_{h'-h, w'-w, c, c'}, with indices \Delta h, \Delta w, c'.

b^{(l)}_c is the bias term for the c-th channel of the l-th layer.

In order to preserve the translational invariance, BatchNorm treats all outputs from the same kernel in the same batch as more data in a batch. That is, it is applied once per kernel c (equivalently, once per channel c), not per activation x^{(l+1)}_{h, w, c}:

\begin{aligned}

\mu^{(l)}_c &= \frac{1}{BHW} \sum_{b=1}^B \sum_{h=1}^H \sum_{w=1}^W x^{(l)}_{(b), h, w, c} \\

(\sigma^{(l)}_c)^2 &= \frac{1}{BHW} \sum_{b=1}^B \sum_{h=1}^H \sum_{w=1}^W (x_{(b), h, w, c}^{(l)} - \mu_c^{(l)})^2

\end{aligned}

where B is the batch size, H is the height of the feature map, and W is the width of the feature map.

That is, even though there are only B data points in a batch, all BHW outputs from the kernel in this batch are treated equally. Let the hidden state of the l-th layer at time t be h_t^{(l)}. The standard RNN, without normalization, satisfiesh^{(l)}_t = \phi(W^{(l)} h_t^{l-1} + U^{(l)} h_{t-1}^{l} + b^{(l)}) where W^{(l)}, U^{(l)}, b^{(l)} are weights and biases, and \phi is the activation function. Applying BatchNorm, this becomesh^{(l)}_t = \phi(\mathrm{BN}(W^{(l)} h_t^{l-1}) + U^{(l)} h_{t-1}^{l}) There are two possible ways to define what a "batch" is in BatchNorm for RNNs: frame-wise and sequence-wise. Concretely, consider applying an RNN to process a batch of sentences. Let h_{b, t}^{(l)} be the hidden state of the l-th layer for the t-th token of the b-th input sentence. Then frame-wise BatchNorm means normalizing over b:

\begin{aligned}

\mu_t^{(l)} &= \frac{1}{B} \sum_{b=1}^B h_{i,t}^{(l)} \\

(\sigma_t^{(l)})^2 &= \frac{1}{B} \sum_{b=1}^B  (h_t^{(l)} - \mu_t^{(l)})^2

\end{aligned}

and sequence-wise means normalizing over (b, t):

\begin{aligned}

\mu^{(l)} &= \frac{1}{BT} \sum_{b=1}^B\sum_{t=1}^T h_{i,t}^{(l)} \\

(\sigma^{(l)})^2 &= \frac{1}{BT} \sum_{b=1}^B\sum_{t=1}^T (h_t^{(l)} - \mu^{(l)})^2

\end{aligned}

Frame-wise BatchNorm is suited for causal tasks such as next-character prediction, where future frames are unavailable, forcing normalization per frame. Sequence-wise BatchNorm is suited for tasks such as speech recognition, where the entire sequences are available, but with variable lengths. In a batch, the smaller sequences are padded with zeroes to match the size of the longest sequence of the batch. In such setups, frame-wise is not recommended, because the number of unpadded frames decreases along the time axis, leading to increasingly poorer statistics estimates.

Improvements

BatchNorm has been very popular and there were many attempted improvements. Some examples include:

ghost batching: randomly partition a batch into sub-batches and perform BatchNorm separately on each;

weight decay on \gamma and \beta;

and combining BatchNorm with GroupNorm.

A particular problem with BatchNorm is that during training, the mean and variance are calculated on the fly for each batch (usually as an exponential moving average), but during inference, the mean and variance were frozen from those calculated during training. This train-test disparity degrades performance. The disparity can be decreased by simulating the moving average during inference:

Layer normalization

Layer normalization (LayerNorm) is a popular alternative to BatchNorm. Unlike BatchNorm, which normalizes activations across the batch dimension for a given feature, LayerNorm normalizes across all the features within a single data sample. Compared to BatchNorm, LayerNorm's performance is not affected by batch size. It is a key component of transformer models.

For a given data input and layer, LayerNorm computes the mean \mu and variance \sigma^2 over all the neurons in the layer. Similar to BatchNorm, learnable parameters \gamma (scale) and \beta (shift) are applied. It is defined by:

\hat{x_i} = \frac{x_i - \mu}{\sqrt{\sigma^2 + \epsilon}}, \quad y_i = \gamma_i \hat{x_i} + \beta_i

where:

\mu = \frac 1D \sum_{i=1}^D x_i, \quad \sigma^2 = \frac 1D \sum_{i=1}^D (x_i - \mu)^2

and the index i ranges over the neurons in that layer.

Examples

For example, in CNN, a LayerNorm applies to all activations in a layer. In the previous notation, we have:

\begin{aligned}

\mu^{(l)} &= \frac{1}{HWC} \sum_{h=1}^H \sum_{w=1}^W\sum_{c=1}^C x^{(l)}_{h, w, c} \\

(\sigma^{(l)})^2 &= \frac{1}{HWC}  \sum_{h=1}^H \sum_{w=1}^W\sum_{c=1}^C (x_{h, w, c}^{(l)} - \mu^{(l)})^2 \\

\hat{x}^{(l)}_{h,w,c} &= \frac{\hat{x}^{(l)}_{h,w,c} - \mu^{(l)}}{\sqrt{(\sigma^{(l)})^2 + \epsilon}} \\

y^{(l)}_{h,w,c} &= \gamma^{(l)} \hat{x}^{(l)}_{h,w,c}  + \beta^{(l)}

\end{aligned}

Notice that the batch index b is removed, while the channel index c is added.

In recurrent neural networks LayerNorm is applied individually to each timestep. For example, if the hidden vector in an RNN at timestep t is x^{(t)} \in \mathbb{R}^{D}

, where D is the dimension of the hidden vector, then LayerNorm will be applied with:

\hat{x_{i}}^{(t)} = \frac{x_i^{(t)} - \mu^{(t)}}{\sqrt{(\sigma^{(t)})^2 + \epsilon}}, \quad y_i^{(t)} = \gamma_i \hat{x_i}^{(t)}  + \beta_i

where:

\mu^{(t)} = \frac 1D \sum_{i=1}^D x_i^{(t)}, \quad (\sigma^{(t)})^2 = \frac 1D \sum_{i=1}^D (x_i^{(t)} - \mu^{(t)})^2

Root mean square layer normalization

Root mean square layer normalization (RMSNorm):

\hat{x_i} = \frac{x_i}{\sqrt{\frac 1D \sum_{i=1}^D x_i^2}}, \quad y_i = \gamma \hat{x_i}  + \beta

Essentially, it is LayerNorm where we enforce \mu, \epsilon = 0. It is also called L2 normalization. It is a special case of Lp normalization, or power normalization:

\hat{x_i} = \frac{x_i}{\left(\frac 1D \sum_{i=1}^D |x_i|^p \right)^{1/p}}, \quad y_i = \gamma \hat{x_i}  + \beta

where p > 0 is a constant.

Adaptive

Adaptive layer norm (adaLN) computes the \gamma, \beta in a LayerNorm not from the layer activation itself, but from other data. It was first proposed for CNNs, and has been used effectively in diffusion transformers (DiTs). For example, in a DiT, the conditioning information (such as a text encoding vector) is processed by a multilayer perceptron into \gamma, \beta, which is then applied in the LayerNorm module of a transformer.

Weight normalization

Weight normalization (WeightNorm) is a technique inspired by BatchNorm that normalizes weight matrices in a neural network, rather than its activations.

One example is spectral normalization, which divides weight matrices by their spectral norm. The spectral normalization is used in generative adversarial networks (GANs) such as the Wasserstein GAN. The spectral radius can be efficiently computed by the following algorithm:

{{blockquote|INPUT matrix W and initial guess x

Iterate x \mapsto \frac{1}{\|Wx\|_2}Wx to convergence x^*. This is the eigenvector of W with eigenvalue \|W\|_s.

RETURN x^*, \|Wx^*\|_2}}

By reassigning W_i \leftarrow \frac{W_i}{\|W_i\|_s} after each update of the discriminator, we can upper-bound \|W_i\|_s \leq 1, and thus upper-bound \|D \|_L.

The algorithm can be further accelerated by memoization: at step t, store x^*_i(t). Then, at step t+1, use x^*_i(t) as the initial guess for the algorithm. Since W_i(t+1) is very close to W_i(t), so is x^*_i(t) to x^*_i(t+1), thus allowing rapid convergence.

CNN-specific normalization

There are some activation normalization techniques that are only used for CNNs.

Response normalization

Local response normalization was used in AlexNet. It was applied in a convolutional layer, just after a nonlinear activation function. It was defined by:

b_{x, y}^i=\frac{a_{x, y}^i}{\left(k+\alpha \sum_{j=\max (0, i-n / 2)}^{\min (N-1, i+n / 2)}\left(a_{x, y}^j\right)^2\right)^\beta}

where a_{x,y}^i is the activation of the neuron at location (x,y) and channel i. I.e., each pixel in a channel is suppressed by the activations of the same pixel in its adjacent channels.

k, n, \alpha, \beta are hyperparameters picked by using a validation set.

It was a variant of the earlier local contrast normalization.

b_{x, y}^i=\frac{a_{x, y}^i}{\left(k+\alpha \sum_{j=\max (0, i-n / 2)}^{\min (N-1, i+n / 2)}\left(a_{x, y}^j - \bar a_{x, y}^j\right)^2\right)^\beta}

where \bar a_{x, y}^j is the average activation in a small window centered on location (x,y) and channel i. The hyperparameters k, n, \alpha, \beta, and the size of the small window, are picked by using a validation set.

Similar methods were called divisive normalization, as they divide activations by a number depending on the activations. They were originally inspired by biology, where it was used to explain nonlinear responses of cortical neurons and nonlinear masking in visual perception.

Both kinds of local normalization were obviated by batch normalization, which is a more global form of normalization.

Response normalization reappeared in ConvNeXT-2 as global response normalization.

Group normalization

Group normalization (GroupNorm) is a technique also solely used for CNNs. It can be understood as the LayerNorm for CNN applied once per channel group.

Suppose at a layer l, there are channels 1, 2, \dots, C, then it is partitioned into groups g_1, g_2, \dots, g_G. Then, LayerNorm is applied to each group.

Instance normalization

Instance normalization (InstanceNorm), or contrast normalization, is a technique first developed for neural style transfer, and is also only used for CNNs. It can be understood as the LayerNorm for CNN applied once per channel, or equivalently, as group normalization where each group consists of a single channel:

\begin{aligned}

\mu^{(l)}_c &= \frac{1}{HW} \sum_{h=1}^H \sum_{w=1}^Wx^{(l)}_{h, w, c} \\

(\sigma^{(l)}_c)^2 &= \frac{1}{HW}  \sum_{h=1}^H \sum_{w=1}^W (x_{h, w, c}^{(l)} - \mu^{(l)}_c)^2 \\

\hat{x}^{(l)}_{h,w,c} &= \frac{\hat{x}^{(l)}_{h,w,c} - \mu^{(l)}_c}{\sqrt{(\sigma^{(l)}_c)^2 + \epsilon}} \\

y^{(l)}_{h,w,c} &= \gamma^{(l)}_c \hat{x}^{(l)}_{h,w,c}  + \beta^{(l)}_c

\end{aligned}

Adaptive instance normalization

Adaptive instance normalization (AdaIN) is a variant of instance normalization, designed specifically for neural style transfer with CNNs, rather than just CNNs in general.

In the AdaIN method of style transfer, we take a CNN and two input images, one for content and one for style. Each image is processed through the same CNN, and at a certain layer l, AdaIn is applied.

Let x^{(l), \text{ content}} be the activation in the content image, and x^{(l), \text{ style}} be the activation in the style image. Then, AdaIn first computes the mean and variance of the activations of the content image x'^{(l)}, then uses those as the \gamma, \beta for InstanceNorm on x^{(l), \text{ content}}. Note that x^{(l), \text{ style}} itself remains unchanged. Explicitly, we have:

\begin{aligned}

y^{(l), \text{ content}}_{h,w,c} &= \sigma^{(l),

\text{ style}}_c \left( \frac{x^{(l), \text{ content}}_{h,w,c} - \mu^{(l), \text{ content}}_c}{\sqrt{(\sigma^{(l), \text{ content}}_c)^2 + \epsilon}} \right) + \mu^{(l), \text{ style}}_c

\end{aligned}

Transformers

Some normalization methods were designed for use in transformers.

The original 2017 transformer used the "post-LN" configuration for its LayerNorms. It was difficult to train, and required careful hyperparameter tuning and a "warm-up" in learning rate, where it starts small and gradually increases. The pre-LN convention, proposed several times in 2018, was found to be easier to train, requiring no warm-up, leading to faster convergence.

FixNorm and ScaleNorm both normalize activation vectors in a transformer. The FixNorm method divides the output vectors from a transformer by their L2 norms, then multiplies by a learned parameter g. The ScaleNorm replaces all LayerNorms inside a transformer by division with L2 norm, then multiplying by a learned parameter g' (shared by all ScaleNorm modules of a transformer). Query-Key normalization (QKNorm) normalizes query and key vectors to have unit L2 norm.

In nGPT, many vectors are normalized to have unit L2 norm: hidden state vectors, input and output embedding vectors, weight matrix columns, and query and key vectors.

Miscellaneous

Gradient normalization (GradNorm) normalizes gradient vectors during backpropagation.

See also

Data preprocessing

Feature scaling

References

Further reading

Category:Articles with example Python (programming language) code

Category:Deep learning

Category:Statistical data transformation

Category:Machine learning

Category:Neural networks