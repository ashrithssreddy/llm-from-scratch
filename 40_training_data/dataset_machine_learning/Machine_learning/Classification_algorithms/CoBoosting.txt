CoBoost is a semi-supervised training algorithm proposed by Collins and Singer in 1999. The original application for the algorithm was the task of named-entity recognition using very weak learners, but it can be used for performing semi-supervised learning in cases where data features may be redundant.

It may be seen as a combination of co-training and boosting. Each example is available in two views (subsections of the feature set), and boosting is applied iteratively in alternation with each view using predicted labels produced in the alternate view on the previous iteration. CoBoosting is not a valid boosting algorithm in the PAC learning sense.

Motivation

CoBoosting was an attempt by Collins and Singer to improve on previous attempts to leverage redundancy in features for training classifiers in a semi-supervised fashion. CoTraining, a seminal work by Blum and Mitchell, was shown to be a powerful framework for learning classifiers given a small number of seed examples by iteratively inducing rules in a decision list. The advantage of CoBoosting to CoTraining is that it generalizes the CoTraining pattern so that it could be used with any classifier. CoBoosting accomplishes this feat by borrowing concepts from AdaBoost.

In both CoTrain and CoBoost the training and testing example sets must follow two properties. The first is that the feature space of the examples can separated into two feature spaces (or views) such that each view is sufficiently expressive for classification.

Formally, there exist two functions f_1(x_1) and f_2(x_2) such that for all examples x=(x_1,x_2), f_1(x_1)=f_2(x_2)=f(x). While ideal, this constraint is in fact too strong due to noise and other factors, and both algorithms instead seek to maximize the agreement between the two functions. The second property is that the two views must not be highly correlated.

Algorithm

Input: \{(x_{1,i},x_{2,i})\}_{i=1}^n, \{y_i\}_{i=1}^m

Initialize: \forall i,j : g_j^0(\boldsymbol{x_i})=0.

For t=1,...,T and for j=1,2:

Set pseudo-labels:

\hat{y_i} = \left\{

\begin{array}{ll}

y_i, 1 \le i \le m \\

sign(g_{3-j}^{t-1}(\boldsymbol{x_{3-j,i}})),  m

Set virtual distribution:

D_t^j(i) = \frac{1}{Z_t^j}e^{-\hat{y_i}g_j^{t-1}(\boldsymbol{x_{j,i}})}

where Z_t^j = \sum_{i=1}^ne^{-\hat{y_i}g_j^{t-1}(\boldsymbol{x_{j,i}})}

Find the weak hypothesis h_t^j that minimizes expanded training error.

Choose value for \alpha_t that minimizes expanded training error.

Update the value for current strong non-thresholded classifier:

\forall i:g_j^t(\boldsymbol{x_{j,i}}) = g_j^{t-1}(\boldsymbol{x_{j,i}})+\alpha_th_t^j(\boldsymbol{x_{j,i}})

The final strong classifier output is

f(\boldsymbol{x}) = sign\left(\sum_{j=1}^2g_j^T(\boldsymbol{x_j})\right)

Setting up AdaBoost

CoBoosting builds on the AdaBoost algorithm, which gives CoBoosting its generalization ability since AdaBoost can be used in conjunction with many other learning algorithms. This build up assumes a two class classification task, although it can be adapted to multiple class classification. In the AdaBoost framework, weak classifiers are generated in series as well as a distribution over examples in the training set. Each weak classifier is given a weight and the final strong classifier is defined as the sign of the sum of the weak classifiers weighted by their assigned weight. (See AdaBoost Wikipedia page for notation). In the AdaBoost framework Schapire and Singer have shown that the training error is bounded by the following equation:

\frac{1}{m}\sum_{i=1}^m e^{\left(-y_i\left(\sum_{t=1}^T\alpha_t h_t(\boldsymbol{x_i})\right)\right)}=\prod_tZ_t

Where Z_t is the normalizing factor for the distribution D_{t+1}. Solving for Z_t in the equation for D_t(i) we get:

Z_t = \sum_{i:x_t\notin x_i}D_t(i) + \sum_{i:x_t\in x_i}D_t(i)e^{-y_i\alpha_i h_t(\boldsymbol{x_i})}

Where x_t is the feature selected in the current weak hypothesis. Three equations are defined describing the sum of the distributions for in which the current hypothesis has selected either correct or incorrect label. Note that it is possible for the classifier to abstain from selecting a label for an example, in which the label provided is 0. The two labels are selected to be either -1 or 1.

W_0 = \sum_{i:h_t(x_i)=0} D_t(i)

W_+ = \sum_{i:h_t(x_i)=y_i} D_t(i)

W_- = \sum_{i:h_t(x_i)=-y_i} D_t(i)

Schapire and Singer have shown that the value Z_t can be minimized (and thus the training error) by selecting \alpha_t to be as follows:

\alpha_t = \frac{1}{2}\ln\left(\frac{W_+}{W_-}\right)

Providing confidence values for the current hypothesized classifier based on the number of correctly classified vs. the number of incorrectly classified examples weighted by the distribution over examples. This equation can be smoothed to compensate for cases in which W_- is too small. Deriving Z_t from this equation we get:

Z_t = W_0 + 2\sqrt{W_+W_-}

The training error thus is minimized by selecting the weak hypothesis at every iteration that minimizes the previous equation.

AdaBoost with two views

CoBoosting extends this framework in the case where one has a labeled training set (examples from 1...m) and an unlabeled training set (from m_1...n), as well as satisfy the conditions of redundancy in features in the form of x_i=(x_{1,i},x_{2,i}). The algorithm trains two classifiers in the same fashion as AdaBoost that agree on the labeled training sets correct labels and maximizes the agreement between the two classifiers on the unlabeled training set. The final classifier is the sign of the sum of the two strong classifiers. The bounded training error on CoBoost is extended as follows, where Z_{CO} is the extension of Z_t:

Z_{CO} = \sum_{i=1}^m e^{-y_ig_1(\boldsymbol{x_{1,i}})}

+ \sum_{i=1}^m e^{-y_ig_2(\boldsymbol{x_{2,i}})}

+ \sum_{i=m+1}^n e^{-f_2(\boldsymbol{x_{2,i}})g_1(\boldsymbol{x_{1,i}})}

+ \sum_{i=m+1}^n e^{-f_1(\boldsymbol{x_{1,i}})g_2(\boldsymbol{x_{2,i}})}

Where g_j is the summation of hypotheses weight by their confidence values for the j^{th} view (j = 1 or 2). f_j is the sign of g_j. At each iteration of CoBoost both classifiers are updated iteratively. If g_j^{t-1} is the strong classifier output for the j^{th} view up to the t-1 iteration we can set the pseudo-labels for the jth update to be:

\hat{y_i} = \left\{

\begin{array}{ll}

y_i   1 \le i \le m \\

sign(g_{3-j}^{t-1}(\boldsymbol{x_{3-j,i}}))  m

In which 3-j selects the other view to the one currently being updated. Z_{CO} is split into two such that Z_{CO} = Z_{CO}^1+Z_{CO}^2. Where

Z_{CO}^j = \sum_{i=1}^n e^{-\hat{y_i}(g_j^{t-1}(\boldsymbol{x_i})+\alpha_t^jg_t^j(\boldsymbol{x_{j,i}}))}

The distribution over examples for each view j at iteration t is defined as follows:

D_t^j(i) = \frac{1}{Z_t^j}e^{-\hat{y_i}g_j^{t-1}(\boldsymbol{x_{j,i}})}

At which point Z_{CO}^j can be rewritten as

Z_{CO}^j = \sum_{i=1}^n D_t^j e^{-\hat{y_i}\alpha_t^jg_t^j(\boldsymbol{x_{j,i}})}

Which is identical to the equation in AdaBoost. Thus the same process can be used to update the values of \alpha_t^j as in AdaBoost using \hat{y_i} and D_t^j. By alternating this, the minimization of Z_{CO}^1 and Z_{CO}^2 in this fashion Z_{CO} is minimized in a greedy fashion.

References

Footnotes

Category:Classification algorithms